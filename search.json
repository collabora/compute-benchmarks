[
  {
    "objectID": "x2. gridrun.html",
    "href": "x2. gridrun.html",
    "title": "Grid run",
    "section": "",
    "text": "source\n\ngrid_run\n\n grid_run (fun, **kwargs)\n\n\nsource\n\n\ngrid_show\n\n grid_show (r, figsize=(6, 6), colorfun=&lt;ufunc 'log'&gt;, textfun=&lt;function\n            &lt;lambda&gt;&gt;)\n\n\nr = grid_run(lambda localx, localy: localx * localy, localx = [1,2,3], localy=[2,3,4])\nr['results']\n\narray([[ 2.,  3.,  4.],\n       [ 4.,  6.,  8.],\n       [ 6.,  9., 12.]])\n\n\n\ngrid_show(r, figsize=(3,3))\n\n\n\n\nTo highlight the highest numbers use colorfun.\n\ngrid_show(r, figsize=(3,3), colorfun=lambda x: -np.log(x))"
  },
  {
    "objectID": "x1. gl_helpers.html",
    "href": "x1. gl_helpers.html",
    "title": "OpenGL helpers",
    "section": "",
    "text": "import OpenGL\n\n\nOpenGL.__version__\n\n'3.1.7'\n\n\n\nsource\n\ncomputeShader\n\n computeShader (src)\n\n\nsource\n\n\ncreateTexture\n\n createTexture (w, h, texid=0, fmt=None, output=True, src=None)\n\n\nsource\n\n\ndownloadTextureFloat\n\n downloadTextureFloat (texture, w, h)\n\n\nsource\n\n\ndownloadTexture\n\n downloadTexture (texture, w, h)\n\n\nsource\n\n\nshowShaderDisassembly\n\n showShaderDisassembly (source)\n\n\nsource\n\n\nshowLastShaderDisassembly\n\n showLastShaderDisassembly ()"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html",
    "href": "a1. estimate gflops (dot products, no loops).html",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "",
    "text": "Here we are trying to use dot products between 2 or 3 arrays of vectors. Unfortunately all of these experiments showed that this task is still very memory-bound:\nFMA is the count of multiply-accumulate instructions in the shader, % FMA is the ration of FMAs to all instructions, GFLOPS is the achieved multiplication rate per second, GOPS is the amount of instructions issued per second (including in the ADD/SF unit) â€“ this is what ARM Mali marketing numbers are based on and finally BW is the total memory bandwidth require to fetch the input vectors and save the results.\nWe are getting around 50% of the expected GOPS. We need a different approach."
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-1-16-fmas-per-invocation-2-vec4-loads-1-vec4-store",
    "href": "a1. estimate gflops (dot products, no loops).html#test-1-16-fmas-per-invocation-2-vec4-loads-1-vec4-store",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 1: 16 FMAs per invocation (2 vec4 loads + 1 vec4 store)",
    "text": "Test 1: 16 FMAs per invocation (2 vec4 loads + 1 vec4 store)\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w*2, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w*2, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(2,{unrolly});\n      highp vec4 x, y;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      highp vec4 r = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w, h)\n    MACs = output.sum()\n#     print(MACs, elapsed, w*h*2*4*4)\n    gflops, mem_mbps = MACs / elapsed / 1e9, w*h*2*4*4 / elapsed / 1024 / 1024\n    return gflops\n\ngflops = test(localy=8)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 1, local_size_y = 8) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(2,1);\n      highp vec4 x, y;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      highp vec4 r = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r);\n    }\n    \n1.2023323586109347\nFMAs: 64.00% (16 / 25)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *LSHIFT_OR.i32 r0:t0, r60, #0, 0x00000001 /* 0.000000 */\n    +NOP t1\n    *MKVEC.v2i16 t0, t0, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r1\n}\n\nclause_3:\nds(0) nbb attr ncph dwb(0) \n{\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r5\n}\n\nclause_6:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r4, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r0:t0, r3, r7, t0\n    +NOP t1\n}\n\nclause_8:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 t0, r2, r6, r0\n    +NOP t1\n    *FMA.f32 r0:t0, r1, r5, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r7, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r8, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r5, t0\n    +NOP t1\n    *FMA.f32 r9:t0, r1, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r10:t0, r3, r5, t0\n    +NOP t1\n}\n\nclause_14:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *FMA.f32 t0, r2, r8, r10\n    +NOP t1\n    *FMA.f32 r10:t0, r1, r7, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r5, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r7, t0\n    +NOP t1\n    *FMA.f32 r1:t0, r1, r8, t0\n    +NOP t1\n    *MOV.i32 r2:t0, r0\n    +MKVEC.v2i16 t1, r60, r61\n    *DTSEL_IMM.attribute_1 t0, t1\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r6\n}\n\nclause_20:\nds(0) eos store \n{\n    *MOV.i32 r3:t0, r9\n    +MOV.i32 r4:t1, r10\n    *NOP t0\n    +MOV.i32 r5:t1, r1\n    *NOP t0\n    +ST_CVT.v4 t1, r6, r7, r8, @r2\n}\n\nshader7799 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-2-48-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "href": "a1. estimate gflops (dot products, no loops).html#test-2-48-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 2: 48 FMAs per invocation (3 vec4 loads + 1 vec4 store)",
    "text": "Test 2: 48 FMAs per invocation (3 vec4 loads + 1 vec4 store)\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1, membw=False):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w*3, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w*3, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,{unrolly});\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w*3, h)\n    MACs = output.sum()\n#     print(MACs, elapsed, 4*w*h*4*4)\n    if membw:\n        return MACs / elapsed / 1e9, 4*w*h*4*4 / elapsed / 1024 / 1024\n    else:\n        return MACs / elapsed / 1e9\n\n# test(localsz=(1,1), unrollx=4, unrolly=4)\ntest()\ntest()\ngflops = test(localx=8, localy=2, membw=True)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 8, local_size_y = 2) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,1);\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2);\n    }\n    \n(5.032359501523362, 6398.9760100343865)\nFMAs: 73.85% (48 / 65)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *IMUL.i32 r0:t0, r60, 0x00000003 /* 0.000000 */\n    +NOP t1\n    *MKVEC.v2i16 t0, t0, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r1\n}\n\nclause_3:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r5\n}\n\nclause_6:\nds(0) nbb attr ncph \n{\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000002 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r9\n    *FMA.f32 r0:t0, r4, r8, #0.neg\n    +NOP t1\n}\n\nclause_9:\nds(0) nbb ncph dwb(0) \n{\n    *FMA.f32 t0, r3, r7, r0\n    +NOP t1\n    *FMA.f32 t0, r2, r6, t0\n    +NOP t1\n    *FMA.f32 r0:t0, r1, r5, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r7, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r8, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r5, t0\n    +NOP t1\n    *FMA.f32 r13:t0, r1, r6, t0\n    +NOP t1\n    *FMA.f32 r14:t0, r4, r6, #0.neg\n    +NOP t1\n}\n\nclause_15:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r3, r5, r14\n    +NOP t1\n    *FMA.f32 t0, r2, r8, t0\n    +NOP t1\n    *FMA.f32 r14:t0, r1, r7, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r5, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r7, t0\n    +NOP t1\n    *FMA.f32 r15:t0, r1, r8, t0\n    +NOP t1\n    *FMA.f32 r48:t0, r4, r12, #0.neg\n    +NOP t1\n}\n\nclause_21:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r3, r11, r48\n    +NOP t1\n    *FMA.f32 t0, r2, r10, t0\n    +NOP t1\n    *FMA.f32 r48:t0, r1, r9, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r11, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r12, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r9, t0\n    +NOP t1\n    *FMA.f32 r49:t0, r1, r10, t0\n    +NOP t1\n    *FMA.f32 r50:t0, r4, r10, #0.neg\n    +NOP t1\n}\n\nclause_27:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r3, r9, r50\n    +NOP t1\n    *FMA.f32 t0, r2, r12, t0\n    +NOP t1\n    *FMA.f32 r50:t0, r1, r11, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r9, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r10, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r11, t0\n    +NOP t1\n    *FMA.f32 r1:t0, r1, r12, t0\n    +NOP t1\n    *FMA.f32 r2:t0, r8, r12, #0.neg\n    +NOP t1\n}\n\nclause_33:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r7, r11, r2\n    +NOP t1\n    *FMA.f32 t0, r6, r10, t0\n    +NOP t1\n    *FMA.f32 r2:t0, r5, r9, t0\n    +NOP t1\n    *FMA.f32 t0, r8, r11, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r7, r12, t0\n    +NOP t1\n    *FMA.f32 t0, r6, r9, t0\n    +NOP t1\n    *FMA.f32 r3:t0, r5, r10, t0\n    +NOP t1\n    *FMA.f32 r4:t0, r8, r10, #0.neg\n    +NOP t1\n}\n\nclause_39:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 t0, r7, r9, r4\n    +NOP t1\n    *FMA.f32 t0, r6, r12, t0\n    +NOP t1\n    *FMA.f32 r4:t0, r5, r11, t0\n    +NOP t1\n    *FMA.f32 t0, r8, r9, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r7, r10, t0\n    +NOP t1\n    *FMA.f32 t0, r6, r11, t0\n    +NOP t1\n    *FMA.f32 r5:t0, r5, r12, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r6:t1, r13, r49\n}\n\nclause_45:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *NOP t0\n    +FADD.f32 r7:t1, r14, r50\n    *FADD.f32 t0, r0, r48\n    +FADD.f32 r0:t1, t, r2\n    *NOP t0\n    +FADD.f32 r2:t1, r6, r3\n    *NOP t0\n    +FADD.f32 r3:t1, r7, r4\n    *FADD.f32 t0, r15, r1\n    +MOV.i32 r4:t1, r0\n    *FADD.f32 t0, t0, r5\n    +MOV.i32 r5:t1, r2\n    *MOV.i32 r7:t0, t0\n    +MKVEC.v2i16 t1, r60, r61\n    *DTSEL_IMM.attribute_1 t0, t1\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r0\n}\n\nclause_51:\nds(0) eos store \n{\n    *NOP t0\n    +MOV.i32 r6:t1, r3\n    *NOP t0\n    +ST_CVT.v4 t1, r0, r1, r2, @r4\n}\n\nshader7949 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-3-107-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "href": "a1. estimate gflops (dot products, no loops).html#test-3-107-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 3: 107 FMAs per invocation (3 vec4 loads + 1 vec4 store)",
    "text": "Test 3: 107 FMAs per invocation (3 vec4 loads + 1 vec4 store)\nWatch out since itâ€™s doing only 107 multiplications and not 112 as might be naively counted. This means the reported GFLOPS number needs to be corrected manually.\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1, membw=False):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w*3, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w*3, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,{unrolly});\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      r0.x -= 5.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w*3, h)\n#     assert(output[0,0,0] == reps * 4 * 4)\n    MACs = output.sum()\n#     print(wh, unrollx, elapsed)\n#     print(MACs, elapsed, 4*w*h*4*4)\n\n    if membw:\n        print(output[0,0].sum())\n        return MACs / elapsed / 1e9, 4*w*h*4*4 / elapsed / 1024 / 1024\n    else:\n        return MACs / elapsed / 1e9\n\n# test(localsz=(1,1), unrollx=4, unrolly=4)\ntest()\ntest()\ngflops = test(localx=8, localy=2, membw=True)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n107.0\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 8, local_size_y = 2) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,1);\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      r0.x -= 5.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2);\n    }\n    \n(9.985058991414952, 5695.697529967095)\nFMAs: 82.95% (107 / 129)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *IMUL.i32 r0:t0, r60, 0x00000003 /* 0.000000 */\n    +IADD.s32 t1, t, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r1\n}\n\nclause_3:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *NOP t0\n    +FADD.f32 t1, r3, r3\n    *FMA.f32 t0, r4, t1, #0.neg\n    +FADD.f32 t1, r1, r1\n    *FMA.f32 r5:t0, r2, t1, t0\n    +NOP t1\n    *FMA.f32 t0, r4, r1, #0.neg\n    +FADD.f32 t1, r2, r2\n    *FMA.f32 t0, r3, t1, t0\n    +NOP t1\n    *FMA.f32 r6:t0, r4, r1, t0\n    +NOP t1\n    *MKVEC.v2i16 t0, r0, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r7\n}\n\nclause_8:\nds(0) nbb attr ncph dwb(0) \n{\n    *FMA.f32 r6:t0, r10, r7, r6\n    +FADD.f32 t1, r7, r7\n    *FMA.f32 r5:t0, r8, t1, r5\n    +FADD.f32 t1, r8, r8\n    *FMA.f32 r6:t0, r9, t1, r6\n    +FADD.f32 t1, r9, r9\n    *FMA.f32 r5:t0, r10, t1, r5\n    +NOP t1\n    *FMA.f32 t0, r10, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r11:t0, r9, r7, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000002 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r12\n}\n\nclause_14:\nds(0) nbb ncph \n{\n    *FMA.f32 r0:t0, r10, r8, r11\n    +NOP t1\n    *FMA.f32 r6:t0, r10, r7, r6\n    +NOP t1\n    *FMA.f32 r11:t0, r10, r1, #0.neg\n    +NOP t1\n    *FMA.f32 r48:t0, r10, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r49:t0, r10, r2, #0.neg\n    +NOP t1\n    *FMA.f32 r50:t0, r10, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r51:t0, r10, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r52:t0, r10, r13, #0.neg\n    +NOP t1\n}\n\nclause_20:\nds(0) nbb ncph \n{\n    *FMA.f32 r53:t0, r10, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r54:t0, r10, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r10:t0, r10, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r11:t0, r9, r2, r11\n    +NOP t1\n    *FMA.f32 r48:t0, r9, r4, r48\n    +NOP t1\n    *FMA.f32 r49:t0, r9, r1, r49\n    +NOP t1\n    *FMA.f32 r50:t0, r9, r3, r50\n    +NOP t1\n    *FMA.f32 r51:t0, r9, r13, r51\n    +NOP t1\n}\n\nclause_26:\nds(0) nbb ncph \n{\n    *FMA.f32 r52:t0, r9, r12, r52\n    +NOP t1\n    *FMA.f32 r53:t0, r9, r15, r53\n    +NOP t1\n    *FMA.f32 r54:t0, r9, r9, r54\n    +NOP t1\n    *FMA.f32 r10:t0, r9, r14, r10\n    +NOP t1\n    *FMA.f32 r11:t0, r8, r3, r11\n    +NOP t1\n    *FMA.f32 r48:t0, r8, r1, r48\n    +NOP t1\n    *FMA.f32 r49:t0, r8, r4, r49\n    +NOP t1\n    *FMA.f32 r50:t0, r8, r2, r50\n    +NOP t1\n}\n\nclause_32:\nds(0) nbb ncph \n{\n    *FMA.f32 r51:t0, r8, r14, r51\n    +NOP t1\n    *FMA.f32 r52:t0, r8, r15, r52\n    +NOP t1\n    *FMA.f32 r53:t0, r8, r12, r53\n    +NOP t1\n    *FMA.f32 r54:t0, r8, r8, r54\n    +NOP t1\n    *FMA.f32 r8:t0, r8, r13, r10\n    +NOP t1\n    *FMA.f32 t0, r4, r2, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r1, t0\n    +NOP t1\n    *FMA.f32 r10:t0, r4, r2, t0\n    +NOP t1\n}\n\nclause_38:\nds(0) nbb ncph \n{\n    *FMA.f32 r11:t0, r7, r4, r11\n    +NOP t1\n    *FMA.f32 r55:t0, r4, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r56:t0, r4, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r57:t0, r4, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r58:t0, r4, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r4:t0, r4, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r55:t0, r3, r13, r55\n    +NOP t1\n    *FMA.f32 r56:t0, r3, r12, r56\n    +NOP t1\n}\n\nclause_44:\nds(0) nbb ncph \n{\n    *FMA.f32 r57:t0, r3, r15, r57\n    +NOP t1\n    *FMA.f32 r58:t0, r3, r3, r58\n    +NOP t1\n    *FMA.f32 r4:t0, r3, r14, r4\n    +NOP t1\n    *FMA.f32 r55:t0, r2, r14, r55\n    +NOP t1\n    *FMA.f32 r56:t0, r2, r15, r56\n    +NOP t1\n    *FMA.f32 r57:t0, r2, r12, r57\n    +NOP t1\n    *FMA.f32 r58:t0, r2, r2, r58\n    +NOP t1\n    *FMA.f32 r4:t0, r2, r13, r4\n    +NOP t1\n}\n\nclause_50:\nds(0) nbb ncph \n{\n    *FMA.f32 r2:t0, r7, r2, r48\n    +NOP t1\n    *FMA.f32 r48:t0, r7, r3, r49\n    +NOP t1\n    *FMA.f32 r3:t0, r3, r1, r10\n    +NOP t1\n    *FMA.f32 r0:t0, r9, r7, r0\n    +NOP t1\n    *FMA.f32 r6:t0, r15, r12, r6\n    +FADD.f32 t1, r12, r12\n    *FMA.f32 r5:t0, r13, t1, r5\n    +FADD.f32 t1, r13, r13\n    *FMA.f32 r6:t0, r14, t1, r6\n    +NOP t1\n    *FMA.f32 r9:t0, r7, r1, r50\n    +NOP t1\n}\n\nclause_56:\nds(0) nbb ncph \n{\n    *FMA.f32 r10:t0, r1, r15, r55\n    +NOP t1\n    *FMA.f32 r49:t0, r1, r14, r56\n    +NOP t1\n    *FMA.f32 r50:t0, r1, r13, r57\n    +NOP t1\n    *FMA.f32 r55:t0, r1, r1, r58\n    +NOP t1\n    *FMA.f32 r1:t0, r1, r12, r4\n    +NOP t1\n    *FMA.f32 r4:t0, r7, r15, r51\n    +NOP t1\n    *FMA.f32 r51:t0, r7, r14, r52\n    +NOP t1\n    *FMA.f32 r52:t0, r7, r13, r53\n    +NOP t1\n}\n\nclause_62:\nds(0) nbb ncph \n{\n    *FMA.f32 r53:t0, r7, r7, r54\n    +NOP t1\n    *FMA.f32 r7:t0, r7, r12, r8\n    +NOP t1\n    *FMA.f32 t0, r11, r12, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r48, r13, t0\n    +NOP t1\n    *FMA.f32 t0, r2, r14, t0\n    +NOP t1\n    *FMA.f32 t0, r9, r15, t0\n    +NOP t1\n    *FMA.f32 r8:t0, t0, 0x3e800000 /* 0.250000 */, r10\n    +NOP t1\n    *FMA.f32 r10:t0, r11, r14, #0.neg\n    +NOP t1\n}\n\nclause_68:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r48, r15, r10\n    +NOP t1\n    *FMA.f32 r10:t0, r2, r12, t0\n    +NOP t1\n    *FMA.f32 t0, r15, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r54:t0, r14, r12, t0\n    +NOP t1\n    *FMA.f32 t0, r11, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r56:t0, r48, r14, t0\n    +NOP t1\n    *FMA.f32 t0, r15, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r57:t0, r14, r14, t0\n    +NOP t1\n}\n\nclause_74:\nds(0) nbb ncph \n{\n    *FMA.f32 r10:t0, r9, r13, r10\n    +NOP t1\n    *FMA.f32 r54:t0, r15, r13, r54\n    +NOP t1\n    *FMA.f32 r56:t0, r2, r13, r56\n    +NOP t1\n    *FMA.f32 r57:t0, r13, r13, r57\n    +NOP t1\n    *FMA.f32 r13:t0, r11, r13, #0.neg\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r0:t1, r0, r3\n    *FMA.f32 t0, r48, r12, r13\n    +NOP t1\n    *FMA.f32 r3:t0, r2, r15, t0\n    +NOP t1\n}\n\nclause_80:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 t0, r9, r14, r3\n    +NOP t1\n    *FMA.f32 r3:t0, t0, 0x3e800000 /* 0.250000 */, r49\n    +NOP t1\n    *FMA.f32 r10:t0, r10, 0x3e800000 /* 0.250000 */, r50\n    +NOP t1\n    *FMA.f32 r13:t0, r14, r12, r54\n    +FADD.f32 t1, r14, r14\n    *FMA.f32 r5:t0, r15, t1, r5\n    +NOP t1\n    *FMA.f32 r6:t0, r15, r12, r6\n    +NOP t1\n    *FMA.f32 r14:t0, r9, r12, r56\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r4:t1, r11, r4\n}\n\nclause_86:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *NOP t0\n    +FADD.f32 r2:t1, r2, r52\n    *FADD.f32 t0, r9, 0xc0a00000 /* -5.000000 */\n    +FADD.f32 r7:t1, t, r7\n    *NOP t0\n    +FADD.f32 r4:t1, r4, r8\n    *FMA.f32 t0, r14, 0x3e800000 /* 0.250000 */, r1\n    +FADD.f32 r1:t1, r7, t\n    *NOP t0\n    +MKVEC.v2i16 r7:t1, r60, r61\n    *NOP t0\n    +FADD.f32 r4:t1, r4, r6\n    *FADD.f32 t0, r2, r10\n    +FADD.f32 r2:t1, t, r5\n    *DTSEL_IMM.attribute_1 t0, r7\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r5\n}\n\nclause_93:\nds(0) eos store \n{\n    *NOP t0\n    +FADD.f32 r11:t1, r48, r51\n    *NOP t0\n    +FADD.f32 r15:t1, r53, r55\n    *NOP t0\n    +FADD.f32 r0:t1, r0, r13\n    *NOP t0\n    +FADD.f32 r3:t1, r11, r3\n    *FMA.f32 t0, r12, r12, r57\n    +FADD.f32 t1, r15, t\n    *NOP t0\n    +FADD.f32 r1:t1, r1, t1\n    *FADD.f32 t0, r3, r0\n    +MOV.i32 r3:t1, t\n    *NOP t0\n    +ST_CVT.v4 t1, r5, r6, r7, @r1\n}\n\nshader14645 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-4-169-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "href": "a1. estimate gflops (dot products, no loops).html#test-4-169-fmas-per-invocation-3-vec4-loads-1-vec4-store",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 4: 169 FMAs per invocation (3 vec4 loads + 1 vec4 store)",
    "text": "Test 4: 169 FMAs per invocation (3 vec4 loads + 1 vec4 store)\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1, membw=False):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w*3, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w*3, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,{unrolly});\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      r0.x += 9.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w*3, h)\n#     assert(output[0,0,0] == reps * 4 * 4)\n    MACs = output.sum()\n#     print(wh, unrollx, elapsed)\n#     print(MACs, elapsed, 4*w*h*4*4)\n\n    if membw:\n        print(output[0,0].sum())\n        return MACs / elapsed / 1e9, 4*w*h*4*4 / elapsed / 1024 / 1024\n    else:\n        return MACs / elapsed / 1e9\n\n# test(localsz=(1,1), unrollx=4, unrolly=4)\ntest()\ntest()\ngflops = test(localx=8, localy=2, membw=True)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n169.0\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 8, local_size_y = 2) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(3,1);\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      r0.x += 9.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2);\n    }\n    \n(17.302189172289815, 6248.768163300396)\nFMAs: 85.79% (169 / 197)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *IMUL.i32 r0:t0, r60, 0x00000003 /* 0.000000 */\n    +NOP t1\n    *MKVEC.v2i16 t0, t0, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r1\n}\n\nclause_3:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *FMA.f32 t0, r4, r1, #0.neg\n    +FADD.f32 t1, r2, r2\n    *FMA.f32 r5:t0, r3, t1, t0\n    +FADD.f32 t1, r3, r3\n    *FMA.f32 t0, r4, t1, #0.neg\n    +FADD.f32 t1, r1, r1\n    *FMA.f32 r6:t0, r2, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000002 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r7\n}\n\nclause_8:\nds(0) nbb attr ncph dwb(0) \n{\n    *FMA.f32 t0, r10, r7, #0.neg\n    +FADD.f32 t1, r8, r8\n    *FMA.f32 r11:t0, r9, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r0, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r12\n}\n\nclause_12:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r15, r12, #0.neg\n    +FADD.f32 t1, r13, r13\n    *FMA.f32 r0:t0, r14, t1, t0\n    +FADD.f32 t1, r14, r14\n    *FMA.f32 t0, r15, t1, #0.neg\n    +FADD.f32 t1, r12, r12\n    *FMA.f32 r16:t0, r13, t1, t0\n    +NOP t1\n}\n\nclause_15:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r4, r2, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r3, r1, t0\n    +NOP t1\n    *FMA.f32 r17:t0, r4, r2, t0\n    +NOP t1\n    *FMA.f32 r5:t0, r4, r1, r5\n    +NOP t1\n    *FMA.f32 r17:t0, r3, r1, r17\n    +NOP t1\n    *FMA.f32 t0, r4, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r18:t0, r3, r3, t0\n    +NOP t1\n    *FMA.f32 r19:t0, r5, r1, #0.neg\n    +NOP t1\n}\n\nclause_21:\nds(0) nbb ncph \n{\n    *FMA.f32 r19:t0, r17, r2, r19\n    +NOP t1\n    *FMA.f32 r18:t0, r2, r2, r18\n    +NOP t1\n    *FMA.f32 t0, r5, r2, #0.neg\n    +NOP t1\n    *FMA.f32 r20:t0, r17, r1, t0\n    +NOP t1\n    *FMA.f32 r19:t0, r6, r3, r19\n    +NOP t1\n    *FMA.f32 r18:t0, r1, r1, r18\n    +NOP t1\n    *FMA.f32 r20:t0, r6, r4, r20\n    +NOP t1\n    *FMA.f32 r19:t0, r18, r4, r19\n    +NOP t1\n}\n\nclause_27:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r5, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r21:t0, r17, r4, t0\n    +NOP t1\n    *FMA.f32 r22:t0, r5, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r23:t0, r4, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r24:t0, r4, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r25:t0, r4, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r26:t0, r4, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r27:t0, r4, r7, #0.neg\n    +NOP t1\n}\n\nclause_33:\nds(0) nbb ncph \n{\n    *FMA.f32 r28:t0, r4, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r29:t0, r4, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r4:t0, r4, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r20:t0, r18, r3, r20\n    +NOP t1\n    *FMA.f32 r22:t0, r17, r3, r22\n    +NOP t1\n    *FMA.f32 r23:t0, r3, r13, r23\n    +NOP t1\n    *FMA.f32 r24:t0, r3, r12, r24\n    +NOP t1\n    *FMA.f32 r25:t0, r3, r15, r25\n    +NOP t1\n}\n\nclause_39:\nds(0) nbb ncph \n{\n    *FMA.f32 r26:t0, r3, r14, r26\n    +NOP t1\n    *FMA.f32 r27:t0, r3, r8, r27\n    +NOP t1\n    *FMA.f32 r28:t0, r3, r7, r28\n    +NOP t1\n    *FMA.f32 r29:t0, r3, r10, r29\n    +NOP t1\n    *FMA.f32 r3:t0, r3, r9, r4\n    +NOP t1\n    *FMA.f32 t0, r10, r8, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r9, r7, t0\n    +NOP t1\n    *FMA.f32 r4:t0, r10, r8, t0\n    +NOP t1\n}\n\nclause_45:\nds(0) nbb ncph \n{\n    *FMA.f32 r11:t0, r10, r7, r11\n    +NOP t1\n    *FMA.f32 r4:t0, r9, r7, r4\n    +NOP t1\n    *FMA.f32 r19:t0, r19, 0x3e800000 /* 0.250000 */, r11\n    +NOP t1\n    *FMA.f32 r30:t0, r11, r7, #0.neg\n    +NOP t1\n    *FMA.f32 r31:t0, r11, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r32:t0, r11, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r11:t0, r11, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r30:t0, r4, r8, r30\n    +NOP t1\n}\n\nclause_51:\nds(0) nbb ncph \n{\n    *FMA.f32 r31:t0, r4, r7, r31\n    +NOP t1\n    *FMA.f32 r32:t0, r4, r10, r32\n    +NOP t1\n    *FMA.f32 r11:t0, r4, r9, r11\n    +NOP t1\n    *FMA.f32 r4:t0, r20, 0x3e800000 /* 0.250000 */, r4\n    +NOP t1\n    *FMA.f32 t0, r15, r13, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r14, r12, t0\n    +NOP t1\n    *FMA.f32 r20:t0, r15, r13, t0\n    +NOP t1\n    *FMA.f32 r0:t0, r15, r12, r0\n    +NOP t1\n}\n\nclause_57:\nds(0) nbb ncph \n{\n    *FMA.f32 r20:t0, r14, r12, r20\n    +NOP t1\n    *FMA.f32 r33:t0, r0, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r34:t0, r0, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r35:t0, r0, r14, #0.neg\n    +FADD.f32 r5:t1, r5, r0\n    *FMA.f32 r0:t0, r0, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r33:t0, r20, r13, r33\n    +NOP t1\n    *FMA.f32 r34:t0, r20, r12, r34\n    +NOP t1\n    *FMA.f32 r35:t0, r20, r15, r35\n    +NOP t1\n}\n\nclause_63:\nds(0) nbb ncph \n{\n    *FMA.f32 r0:t0, r20, r14, r0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r17:t1, r17, r20\n    *FADD.f32 t0, r6, r16\n    +FADD.f32 r36:t1, r9, r9\n    *FMA.f32 r20:t0, r10, t1, t0\n    +NOP t1\n    *FMA.f32 t0, r10, r36, #0.neg\n    +FADD.f32 r37:t1, r7, r7\n    *FMA.f32 r36:t0, r8, t1, t0\n    +NOP t1\n    *FMA.f32 r20:t0, r8, r37, r20\n    +NOP t1\n    *FMA.f32 r21:t0, r6, r1, r21\n    +NOP t1\n}\n\nclause_69:\nds(0) nbb ncph \n{\n    *FMA.f32 r6:t0, r6, r2, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r16, r14, r33\n    +NOP t1\n    *FMA.f32 r33:t0, r16, r15, r34\n    +NOP t1\n    *FMA.f32 r34:t0, r16, r12, r35\n    +NOP t1\n    *FMA.f32 r0:t0, r16, r13, r0\n    +NOP t1\n    *FMA.f32 r16:t0, r2, r14, r23\n    +NOP t1\n    *FMA.f32 r23:t0, r2, r15, r24\n    +NOP t1\n    *FMA.f32 r21:t0, r18, r2, r21\n    +NOP t1\n}\n\nclause_75:\nds(0) nbb ncph \n{\n    *FMA.f32 r24:t0, r2, r12, r25\n    +NOP t1\n    *FMA.f32 r25:t0, r2, r13, r26\n    +NOP t1\n    *FMA.f32 r26:t0, r2, r9, r27\n    +NOP t1\n    *FMA.f32 r27:t0, r2, r10, r28\n    +NOP t1\n    *FMA.f32 r28:t0, r2, r7, r29\n    +NOP t1\n    *FMA.f32 r2:t0, r2, r8, r3\n    +NOP t1\n    *FMA.f32 r3:t0, r36, r9, r30\n    +NOP t1\n    *FMA.f32 r29:t0, r36, r10, r31\n    +NOP t1\n}\n\nclause_81:\nds(0) nbb ncph \n{\n    *FMA.f32 r30:t0, r36, r7, r32\n    +NOP t1\n    *FMA.f32 r11:t0, r36, r8, r11\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r4:t1, r17, r4\n    *FMA.f32 t0, r15, r15, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r14, r14, t0\n    +NOP t1\n    *FMA.f32 t0, r13, r13, t0\n    +NOP t1\n    *FMA.f32 r17:t0, r12, r12, t0\n    +NOP t1\n    *FMA.f32 r16:t0, r1, r15, r16\n    +NOP t1\n}\n\nclause_87:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r5:t1, r5, r19\n    *FMA.f32 r19:t0, r17, r15, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r15, r7, #0.neg\n    +NOP t1\n    *FMA.f32 r31:t0, r15, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r32:t0, r15, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r15:t0, r15, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r22:t0, r14, r8, r22\n    +NOP t1\n    *FMA.f32 r31:t0, r14, r7, r31\n    +NOP t1\n}\n\nclause_93:\nds(0) nbb ncph \n{\n    *FMA.f32 r32:t0, r14, r10, r32\n    +NOP t1\n    *FMA.f32 r15:t0, r14, r9, r15\n    +NOP t1\n    *FMA.f32 r23:t0, r1, r14, r23\n    +NOP t1\n    *FMA.f32 r14:t0, r17, r14, r33\n    +NOP t1\n    *FMA.f32 r20:t0, r21, 0x3e800000 /* 0.250000 */, r20\n    +NOP t1\n    *FMA.f32 r21:t0, r13, r9, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r13, r10, r31\n    +NOP t1\n    *FMA.f32 r31:t0, r13, r7, r32\n    +NOP t1\n}\n\nclause_99:\nds(0) nbb ncph \n{\n    *FMA.f32 r15:t0, r13, r8, r15\n    +NOP t1\n    *FMA.f32 r24:t0, r1, r13, r24\n    +NOP t1\n    *FMA.f32 r13:t0, r17, r13, r34\n    +NOP t1\n    *FMA.f32 t0, r10, r10, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r9, r9, t0\n    +NOP t1\n    *FMA.f32 t0, r8, r8, t0\n    +NOP t1\n    *FMA.f32 r32:t0, r7, r7, t0\n    +NOP t1\n    *FMA.f32 r6:t0, r18, r1, r6\n    +NOP t1\n}\n\nclause_105:\nds(0) nbb ncph \n{\n    *FMA.f32 r6:t0, r6, 0x3e800000 /* 0.250000 */, r32\n    +NOP t1\n    *FMA.f32 r0:t0, r17, r12, r0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r18:t1, r18, r17\n    *FMA.f32 r17:t0, r1, r12, r25\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r6:t1, r18, r6\n    *FMA.f32 r18:t0, r12, r10, r21\n    +NOP t1\n    *FMA.f32 r21:t0, r12, r9, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r12, r8, r31\n    +NOP t1\n}\n\nclause_111:\nds(0) nbb ncph \n{\n    *FMA.f32 r12:t0, r12, r7, r15\n    +NOP t1\n    *FMA.f32 r15:t0, r1, r10, r26\n    +NOP t1\n    *FMA.f32 r25:t0, r1, r9, r27\n    +NOP t1\n    *FMA.f32 r26:t0, r1, r8, r28\n    +NOP t1\n    *FMA.f32 r1:t0, r1, r7, r2\n    +NOP t1\n    *FMA.f32 t0, r16, r7, #0.neg\n    +NOP t1\n    *FMA.f32 r2:t0, r23, r8, t0\n    +NOP t1\n    *FMA.f32 r27:t0, r16, r8, #0.neg\n    +NOP t1\n}\n\nclause_117:\nds(0) nbb ncph \n{\n    *FMA.f32 r27:t0, r23, r7, r27\n    +NOP t1\n    *FMA.f32 r2:t0, r24, r9, r2\n    +NOP t1\n    *FMA.f32 r27:t0, r24, r10, r27\n    +NOP t1\n    *FMA.f32 t0, r16, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r28:t0, r23, r10, t0\n    +NOP t1\n    *FMA.f32 r2:t0, r17, r10, r2\n    +NOP t1\n    *FMA.f32 r3:t0, r32, r10, r3\n    +NOP t1\n    *FMA.f32 r10:t0, r16, r10, #0.neg\n    +NOP t1\n}\n\nclause_123:\nds(0) nbb ncph \n{\n    *FMA.f32 r10:t0, r23, r9, r10\n    +NOP t1\n    *FMA.f32 r27:t0, r17, r9, r27\n    +NOP t1\n    *FMA.f32 r9:t0, r32, r9, r29\n    +NOP t1\n    *FMA.f32 r28:t0, r24, r7, r28\n    +NOP t1\n    *FMA.f32 r10:t0, r24, r8, r10\n    +NOP t1\n    *FMA.f32 r28:t0, r17, r8, r28\n    +NOP t1\n    *FMA.f32 r8:t0, r32, r8, r30\n    +NOP t1\n    *FMA.f32 r11:t0, r32, r7, r11\n    +NOP t1\n}\n\nclause_129:\nds(0) nbb ncph \n{\n    *FMA.f32 r7:t0, r17, r7, r10\n    +NOP t1\n    *FMA.f32 r5:t0, r19, 0x3e800000 /* 0.250000 */, r5\n    +NOP t1\n    *FMA.f32 r2:t0, r2, 0x3e800000 /* 0.250000 */, r18\n    +NOP t1\n    *FMA.f32 r4:t0, r14, 0x3e800000 /* 0.250000 */, r4\n    +NOP t1\n    *FMA.f32 r14:t0, r27, 0x3e800000 /* 0.250000 */, r21\n    +NOP t1\n    *FMA.f32 r13:t0, r13, 0x3e800000 /* 0.250000 */, r20\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r10:t1, r16, r15\n    *FMA.f32 r16:t0, r28, 0x3e800000 /* 0.250000 */, r22\n    +NOP t1\n}\n\nclause_135:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 r0:t0, r0, 0x3e800000 /* 0.250000 */, r6\n    +NOP t1\n    *FMA.f32 r6:t0, r7, 0x3e800000 /* 0.250000 */, r12\n    +NOP t1\n    *FMA.f32 r3:t0, r3, 0x3e800000 /* 0.250000 */, r5\n    +NOP t1\n    *FADD.f32 t0, r17, 0x41100000 /* 9.000000 */\n    +FADD.f32 r1:t1, t, r1\n    *FMA.f32 r7:t0, r8, 0x3e800000 /* 0.250000 */, r13\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r15:t1, r23, r25\n    *NOP t0\n    +FADD.f32 r18:t1, r24, r26\n    *NOP t0\n    +FADD.f32 r2:t1, r10, r2\n}\n\nclause_141:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *NOP t0\n    +FADD.f32 r5:t1, r15, r14\n    *NOP t0\n    +FADD.f32 r8:t1, r18, r16\n    *NOP t0\n    +FADD.f32 r1:t1, r1, r6\n    *NOP t0\n    +MKVEC.v2i16 r6:t1, r60, r61\n    *NOP t0\n    +FADD.f32 r2:t1, r2, r3\n    *FMA.f32 t0, r9, 0x3e800000 /* 0.250000 */, r4\n    +FADD.f32 r3:t1, r5, t\n    *NOP t0\n    +FADD.f32 r4:t1, r8, r7\n    *DTSEL_IMM.attribute_1 t0, r6\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r5\n}\n\nclause_148:\nds(0) eos store \n{\n    *FMA.f32 t0, r11, 0x3e800000 /* 0.250000 */, r0\n    +NOP t1\n    *FADD.f32 t0, r1, t0\n    +MOV.i32 r8:t1, t\n    *MOV.i32 r9:t0, r4\n    +MOV.i32 r10:t1, r3\n    *NOP t0\n    +MOV.i32 r11:t1, r2\n    *NOP t0\n    +ST_CVT.v4 t1, r5, r6, r7, @r8\n}\n\nshader16595 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)\n\nndecode.dump.0278\npandecode: dump command stream to file pandecode.dump.0279\npandecode: dump command stream to file pandecode.dump.0280\npandecode: dump command stream to file pandecode.dump.0281\npandecode: dump command stream to file pandecode.dump.0282\npandecode: dump command stream to file pandecode.dump.0283\npandecode: dump command stream to file pandecode.dump.0284\npandecode: dump command stream to file pandecode.dump.0285\npandecode: dump command stream to file pandecode.dump.0286\npandecode: dump command stream to file pandecode.dump.0287\npandecode: dump command stream to file pandecode.dump.0288\npandecode: dump command stream to file pandecode.dump.0289\npandecode: dump command stream to file pandecode.dump.0290\npandecode: dump command stream to file pandecode.dump.0291\npandecode: dump command stream to file pandecode.dump.0292\npandecode: dump command stream to file pandecode.dump.0293\npandecode: dump command stream to file pandecode.dump.0294\npandecode: dump command stream to file pandecode.dump.0295\npandecode: dump command stream to file pandecode.dump.0296\npandecode: dump command stream to file pandecode.dump.0297\npandecode: dump command stream to file pandecode.dump.0298\npandecode: dump command stream to file pandecode.dump.0299\npandecode: dump command stream to file pandecode.dump.0300\npandecode: dump command stream to file pandecode.dump.0301\npandecode: dump command stream to file pandecode.dump.0302\npandecode: dump command stream to file pandecode.dump.0303\npandecode: dump command stream to file pandecode.dump.0304\npandecode: dump command stream to file pandecode.dump.0305\npandecode: dump command stream to file pandecode.dump.0306\npandecode: dump command stream to file pandecode.dump.0307\npandecode: dump command stream to file pandecode.dump.0308\npandecode: dump command stream to file pandecode.dump.0309\npandecode: dump command stream to file pandecode.dump.0310\npandecode: dump command stream to file pandecode.dump.0311\npandecode: dump command stream to file pandecode.dump.0312\npandecode: dump command stream to file pandecode.dump.0313\npandecode: dump command stream to file pandecode.dump.0314\npandecode: dump command stream to file pandecode.dump.0315\npandecode: dump command stream to file pandecode.dump.0316\npandecode: dump command stream to file pandecode.dump.0317\npandecode: dump command stream to file pandecode.dump.0318\npandecode: dump command stream to file pandecode.dump.0319\npandecode: dump command stream to file pandecode.dump.0320\npandecode: dump command stream to file pandecode.dump.0321\npandecode: dump command stream to file pandecode.dump.0322\npandecode: dump command stream to file pandecode.dump.0323\npandecode: dump command stream to file pandecode.dump.0324\npandecode: dump command stream to file pandecode.dump.0325\npandecode: dump command stream to file pandecode.dump.0326\npandecode: dump command stream to file pandecode.dump.0327\npandecode: dump command stream to file pandecode.dump.0328\npandecode: dump command stream to file pandecode.dump.0329\npandecode: dump command stream to file pandecode.dump.0330\npandecode: dump command stream to file pandecode.dump.0331\npandecode: dump command stream to file pandecode.dump.0332\npandecode: dump command stream to file pandecode.dump.0333\npandecode: dump command stream to file pandecode.dump.0334\npandecode: dump command stream to file pandecode.dump.0335\npandecode: dump command stream to file pandecode.dump.0336\npandecode: dump command stream to file pandecode.dump.0337\npandecode: dump command stream to file pandecode.dump.0338\npandecode: dump command stream to file pandecode.dump.0339\npandecode: dump command stream to file pandecode.dump.0340\npandecode: dump command stream to file pandecode.dump.0341\npandecode: dump command stream to file pandecode.dump.0342\npandecode: dump command stream to file pandecode.dump.0343\npandecode: dump command stream to file pandecode.dump.0344\npandecode: dump command stream to file pandecode.dump.0345\npandecode: dump command stream to file pandecode.dump.0346\npandecode: dump command stream to file pandecode.dump.0347\npandeco"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-5-169-fmas-per-invocation-3-vec4-loads-with-overlap-1-vec4-store",
    "href": "a1. estimate gflops (dot products, no loops).html#test-5-169-fmas-per-invocation-3-vec4-loads-with-overlap-1-vec4-store",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 5: 169 FMAs per invocation (3 vec4 loads with overlap + 1 vec4 store)",
    "text": "Test 5: 169 FMAs per invocation (3 vec4 loads with overlap + 1 vec4 store)\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1, membw=False):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w+2, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w+2, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(1,{unrolly});\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      r0.x += 9.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w, h)\n#     assert(output[0,0,0] == reps * 4 * 4)\n    MACs = output.sum()\n#     print(wh, unrollx, elapsed)\n#     print(MACs, elapsed, 4*w*h*4*4)\n\n    if membw:\n        print(output[0,0].sum())\n        return MACs / elapsed / 1e9, 4*w*h*4*4 / elapsed / 1024 / 1024\n    else:\n        return MACs / elapsed / 1e9\n\n# test(localsz=(1,1), unrollx=4, unrolly=4)\ntest()\ntest()\ngflops = test(localx=16, localy=2, membw=True)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n169.0\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 16, local_size_y = 2) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(1,1);\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      r0.x += 9.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2);\n    }\n    \n(23.881990676008602, 8625.094866693657)\nFMAs: 87.56% (169 / 193)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *MKVEC.v2i16 r2:t0, r60, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r3\n}\n\nclause_1:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *FMA.f32 t0, r6, r3, #0.neg\n    +FADD.f32 t1, r4, r4\n    *FMA.f32 r7:t0, r5, t1, t0\n    +FADD.f32 t1, r5, r5\n    *FMA.f32 t0, r6, t1, #0.neg\n    +FADD.f32 t1, r3, r3\n    *FMA.f32 r8:t0, r4, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r60, 0x00000002 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r9\n}\n\nclause_6:\nds(0) nbb attr ncph dwb(0) \n{\n    *FMA.f32 t0, r12, r9, #0.neg\n    +FADD.f32 t1, r10, r10\n    *FMA.f32 r0:t0, r11, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r60, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r13\n}\n\nclause_10:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r16, r13, #0.neg\n    +FADD.f32 t1, r14, r14\n    *FMA.f32 r1:t0, r15, t1, t0\n    +FADD.f32 t1, r15, r15\n    *FMA.f32 t0, r16, t1, #0.neg\n    +FADD.f32 t1, r13, r13\n    *FMA.f32 r17:t0, r14, t1, t0\n    +NOP t1\n    *FMA.f32 t0, r6, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r18:t0, r5, r3, t0\n    +NOP t1\n}\n\nclause_15:\nds(0) nbb ncph \n{\n    *FMA.f32 r18:t0, r6, r4, r18\n    +NOP t1\n    *FMA.f32 r7:t0, r6, r3, r7\n    +NOP t1\n    *FMA.f32 r18:t0, r5, r3, r18\n    +NOP t1\n    *FMA.f32 t0, r6, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r19:t0, r5, r5, t0\n    +NOP t1\n    *FMA.f32 t0, r7, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r20:t0, r18, r4, t0\n    +NOP t1\n    *FMA.f32 r19:t0, r4, r4, r19\n    +NOP t1\n}\n\nclause_21:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r7, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r21:t0, r18, r3, t0\n    +NOP t1\n    *FMA.f32 r20:t0, r8, r5, r20\n    +NOP t1\n    *FMA.f32 r19:t0, r3, r3, r19\n    +NOP t1\n    *FMA.f32 r21:t0, r8, r6, r21\n    +NOP t1\n    *FMA.f32 r20:t0, r19, r6, r20\n    +NOP t1\n    *FMA.f32 t0, r7, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r22:t0, r18, r6, t0\n    +NOP t1\n}\n\nclause_27:\nds(0) nbb ncph \n{\n    *FMA.f32 r23:t0, r7, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r24:t0, r6, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r25:t0, r6, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r26:t0, r6, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r27:t0, r6, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r28:t0, r6, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r29:t0, r6, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r30:t0, r6, r11, #0.neg\n    +NOP t1\n}\n\nclause_33:\nds(0) nbb ncph \n{\n    *FMA.f32 r6:t0, r6, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r21:t0, r19, r5, r21\n    +NOP t1\n    *FMA.f32 r23:t0, r18, r5, r23\n    +NOP t1\n    *FMA.f32 r24:t0, r5, r14, r24\n    +NOP t1\n    *FMA.f32 r25:t0, r5, r13, r25\n    +NOP t1\n    *FMA.f32 r26:t0, r5, r16, r26\n    +NOP t1\n    *FMA.f32 r27:t0, r5, r15, r27\n    +NOP t1\n    *FMA.f32 r28:t0, r5, r10, r28\n    +NOP t1\n}\n\nclause_39:\nds(0) nbb ncph \n{\n    *FMA.f32 r29:t0, r5, r9, r29\n    +NOP t1\n    *FMA.f32 r30:t0, r5, r12, r30\n    +NOP t1\n    *FMA.f32 r5:t0, r5, r11, r6\n    +NOP t1\n    *FMA.f32 t0, r12, r10, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r11, r9, t0\n    +NOP t1\n    *FMA.f32 r6:t0, r12, r10, t0\n    +NOP t1\n    *FMA.f32 r0:t0, r12, r9, r0\n    +NOP t1\n    *FMA.f32 r6:t0, r11, r9, r6\n    +NOP t1\n}\n\nclause_45:\nds(0) nbb ncph \n{\n    *FMA.f32 r20:t0, r20, 0x3e800000 /* 0.250000 */, r0\n    +NOP t1\n    *FMA.f32 r31:t0, r0, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r32:t0, r0, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r33:t0, r0, r11, #0.neg\n    +NOP t1\n    *FMA.f32 r0:t0, r0, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r31:t0, r6, r10, r31\n    +NOP t1\n    *FMA.f32 r32:t0, r6, r9, r32\n    +NOP t1\n    *FMA.f32 r33:t0, r6, r12, r33\n    +NOP t1\n}\n\nclause_51:\nds(0) nbb ncph \n{\n    *FMA.f32 r0:t0, r6, r11, r0\n    +NOP t1\n    *FMA.f32 r6:t0, r21, 0x3e800000 /* 0.250000 */, r6\n    +NOP t1\n    *FMA.f32 t0, r16, r14, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r15, r13, t0\n    +NOP t1\n    *FMA.f32 r21:t0, r16, r14, t0\n    +NOP t1\n    *FMA.f32 r1:t0, r16, r13, r1\n    +NOP t1\n    *FMA.f32 r21:t0, r15, r13, r21\n    +NOP t1\n    *FMA.f32 r34:t0, r1, r13, #0.neg\n    +NOP t1\n}\n\nclause_57:\nds(0) nbb ncph \n{\n    *FMA.f32 r35:t0, r1, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r36:t0, r1, r15, #0.neg\n    +FADD.f32 r7:t1, r7, r1\n    *FMA.f32 r1:t0, r1, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r34:t0, r21, r14, r34\n    +NOP t1\n    *FMA.f32 r35:t0, r21, r13, r35\n    +NOP t1\n    *FMA.f32 r36:t0, r21, r16, r36\n    +NOP t1\n    *FMA.f32 r1:t0, r21, r15, r1\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r18:t1, r18, r21\n}\n\nclause_63:\nds(0) nbb ncph \n{\n    *FADD.f32 t0, r8, r17\n    +FADD.f32 r37:t1, r11, r11\n    *FMA.f32 r21:t0, r12, t1, t0\n    +NOP t1\n    *FMA.f32 t0, r12, r37, #0.neg\n    +FADD.f32 r38:t1, r9, r9\n    *FMA.f32 r37:t0, r10, t1, t0\n    +NOP t1\n    *FMA.f32 r21:t0, r10, r38, r21\n    +NOP t1\n    *FMA.f32 r22:t0, r8, r3, r22\n    +NOP t1\n    *FMA.f32 r8:t0, r8, r4, r23\n    +NOP t1\n    *FMA.f32 r23:t0, r17, r15, r34\n    +NOP t1\n}\n\nclause_69:\nds(0) nbb ncph \n{\n    *FMA.f32 r34:t0, r17, r16, r35\n    +NOP t1\n    *FMA.f32 r35:t0, r17, r13, r36\n    +NOP t1\n    *FMA.f32 r1:t0, r17, r14, r1\n    +NOP t1\n    *FMA.f32 r17:t0, r4, r15, r24\n    +NOP t1\n    *FMA.f32 r24:t0, r4, r16, r25\n    +NOP t1\n    *FMA.f32 r22:t0, r19, r4, r22\n    +NOP t1\n    *FMA.f32 r25:t0, r4, r13, r26\n    +NOP t1\n    *FMA.f32 r26:t0, r4, r14, r27\n    +NOP t1\n}\n\nclause_75:\nds(0) nbb ncph \n{\n    *FMA.f32 r27:t0, r4, r11, r28\n    +NOP t1\n    *FMA.f32 r28:t0, r4, r12, r29\n    +NOP t1\n    *FMA.f32 r29:t0, r4, r9, r30\n    +NOP t1\n    *FMA.f32 r4:t0, r4, r10, r5\n    +NOP t1\n    *FMA.f32 r5:t0, r37, r11, r31\n    +NOP t1\n    *FMA.f32 r30:t0, r37, r12, r32\n    +NOP t1\n    *FMA.f32 r31:t0, r37, r9, r33\n    +NOP t1\n    *FMA.f32 r0:t0, r37, r10, r0\n    +NOP t1\n}\n\nclause_81:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r6:t1, r18, r6\n    *FMA.f32 t0, r16, r16, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r15, r15, t0\n    +NOP t1\n    *FMA.f32 t0, r14, r14, t0\n    +NOP t1\n    *FMA.f32 r18:t0, r13, r13, t0\n    +NOP t1\n    *FMA.f32 r17:t0, r3, r16, r17\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r7:t1, r7, r20\n    *FMA.f32 r20:t0, r18, r16, r23\n    +NOP t1\n}\n\nclause_87:\nds(0) nbb ncph \n{\n    *FMA.f32 r23:t0, r16, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r32:t0, r16, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r33:t0, r16, r11, #0.neg\n    +NOP t1\n    *FMA.f32 r16:t0, r16, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r23:t0, r15, r10, r23\n    +NOP t1\n    *FMA.f32 r32:t0, r15, r9, r32\n    +NOP t1\n    *FMA.f32 r33:t0, r15, r12, r33\n    +NOP t1\n    *FMA.f32 r16:t0, r15, r11, r16\n    +NOP t1\n}\n\nclause_93:\nds(0) nbb ncph \n{\n    *FMA.f32 r24:t0, r3, r15, r24\n    +NOP t1\n    *FMA.f32 r15:t0, r18, r15, r34\n    +NOP t1\n    *FMA.f32 r21:t0, r22, 0x3e800000 /* 0.250000 */, r21\n    +NOP t1\n    *FMA.f32 r22:t0, r14, r11, r23\n    +NOP t1\n    *FMA.f32 r23:t0, r14, r12, r32\n    +NOP t1\n    *FMA.f32 r32:t0, r14, r9, r33\n    +NOP t1\n    *FMA.f32 r16:t0, r14, r10, r16\n    +NOP t1\n    *FMA.f32 r25:t0, r3, r14, r25\n    +NOP t1\n}\n\nclause_99:\nds(0) nbb ncph \n{\n    *FMA.f32 r14:t0, r18, r14, r35\n    +NOP t1\n    *FMA.f32 t0, r12, r12, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r11, r11, t0\n    +NOP t1\n    *FMA.f32 t0, r10, r10, t0\n    +NOP t1\n    *FMA.f32 r33:t0, r9, r9, t0\n    +NOP t1\n    *FMA.f32 t0, r19, r3, r8\n    +NOP t1\n    *FMA.f32 r8:t0, t0, 0x3e800000 /* 0.250000 */, r33\n    +NOP t1\n    *FMA.f32 r1:t0, r18, r13, r1\n    +NOP t1\n}\n\nclause_105:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r19:t1, r19, r18\n    *FMA.f32 r18:t0, r3, r13, r26\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r8:t1, r19, r8\n    *FMA.f32 r19:t0, r13, r12, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r13, r11, r23\n    +NOP t1\n    *FMA.f32 r23:t0, r13, r10, r32\n    +NOP t1\n    *FMA.f32 r13:t0, r13, r9, r16\n    +NOP t1\n    *FMA.f32 r16:t0, r3, r12, r27\n    +NOP t1\n}\n\nclause_111:\nds(0) nbb ncph \n{\n    *FMA.f32 r26:t0, r3, r11, r28\n    +NOP t1\n    *FMA.f32 r27:t0, r3, r10, r29\n    +NOP t1\n    *FMA.f32 r3:t0, r3, r9, r4\n    +NOP t1\n    *FMA.f32 t0, r17, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r4:t0, r24, r10, t0\n    +NOP t1\n    *FMA.f32 t0, r17, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r28:t0, r24, r9, t0\n    +NOP t1\n    *FMA.f32 r4:t0, r25, r11, r4\n    +NOP t1\n}\n\nclause_117:\nds(0) nbb ncph \n{\n    *FMA.f32 r28:t0, r25, r12, r28\n    +NOP t1\n    *FMA.f32 t0, r17, r11, #0.neg\n    +NOP t1\n    *FMA.f32 r29:t0, r24, r12, t0\n    +NOP t1\n    *FMA.f32 r4:t0, r18, r12, r4\n    +NOP t1\n    *FMA.f32 r5:t0, r33, r12, r5\n    +NOP t1\n    *FMA.f32 t0, r17, r12, #0.neg\n    +NOP t1\n    *FMA.f32 r12:t0, r24, r11, t0\n    +NOP t1\n    *FMA.f32 r28:t0, r18, r11, r28\n    +NOP t1\n}\n\nclause_123:\nds(0) nbb ncph \n{\n    *FMA.f32 r11:t0, r33, r11, r30\n    +NOP t1\n    *FMA.f32 r29:t0, r25, r9, r29\n    +NOP t1\n    *FMA.f32 r12:t0, r25, r10, r12\n    +NOP t1\n    *FMA.f32 r29:t0, r18, r10, r29\n    +NOP t1\n    *FMA.f32 r10:t0, r33, r10, r31\n    +NOP t1\n    *FMA.f32 r0:t0, r33, r9, r0\n    +NOP t1\n    *FMA.f32 r9:t0, r18, r9, r12\n    +NOP t1\n    *FMA.f32 r7:t0, r20, 0x3e800000 /* 0.250000 */, r7\n    +NOP t1\n}\n\nclause_129:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 r4:t0, r4, 0x3e800000 /* 0.250000 */, r19\n    +NOP t1\n    *FMA.f32 r6:t0, r15, 0x3e800000 /* 0.250000 */, r6\n    +NOP t1\n    *FMA.f32 r15:t0, r28, 0x3e800000 /* 0.250000 */, r22\n    +NOP t1\n    *FMA.f32 r14:t0, r14, 0x3e800000 /* 0.250000 */, r21\n    +NOP t1\n    *FMA.f32 r1:t0, r1, 0x3e800000 /* 0.250000 */, r8\n    +NOP t1\n    *FMA.f32 r8:t0, r9, 0x3e800000 /* 0.250000 */, r13\n    +NOP t1\n    *FMA.f32 r5:t0, r5, 0x3e800000 /* 0.250000 */, r7\n    +NOP t1\n    *FMA.f32 r0:t0, r0, 0x3e800000 /* 0.250000 */, r1\n    +NOP t1\n}\n\nclause_135:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *NOP t0\n    +FADD.f32 r12:t1, r17, r16\n    *NOP t0\n    +FADD.f32 r16:t1, r24, r26\n    *NOP t0\n    +FADD.f32 r4:t1, r12, r4\n    *FADD.f32 t0, r18, 0x41100000 /* 9.000000 */\n    +FADD.f32 r7:t1, r16, r15\n    *FADD.f32 t0, t0, r3\n    +FADD.f32 r1:t1, t, r8\n    *NOP t0\n    +FADD.f32 r3:t1, r4, r5\n    *FMA.f32 t0, r11, 0x3e800000 /* 0.250000 */, r6\n    +FADD.f32 r4:t1, r7, t\n    *DTSEL_IMM.attribute_1 t0, r2\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r6\n}\n\nclause_142:\nds(0) eos store \n{\n    *FMA.f32 r17:t0, r29, 0x3e800000 /* 0.250000 */, r23\n    +NOP t1\n    *FMA.f32 r9:t0, r10, 0x3e800000 /* 0.250000 */, r14\n    +NOP t1\n    *NOP t0\n    +FADD.f32 t1, r25, r27\n    *NOP t0\n    +FADD.f32 t1, t1, r17\n    *NOP t0\n    +FADD.f32 t1, t1, r9\n    *FADD.f32 r0:t0, r1, r0\n    +MOV.i32 r1:t1, t1\n    *NOP t0\n    +MOV.i32 r2:t1, r4\n    *NOP t0\n    +ST_CVT.v4 t1, r6, r7, r8, @r0\n}\n\nshader19895 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)"
  },
  {
    "objectID": "a1. estimate gflops (dot products, no loops).html#test-5-169-fmas-per-invocation-3-vec4-loads-with-overlap-1-vec4-store-1",
    "href": "a1. estimate gflops (dot products, no loops).html#test-5-169-fmas-per-invocation-3-vec4-loads-with-overlap-1-vec4-store-1",
    "title": "Estimate GFLOPS (dot products, no loops)",
    "section": "Test 5: 169 FMAs per invocation (3 vec4 loads with overlap + 1 vec4 store)",
    "text": "Test 5: 169 FMAs per invocation (3 vec4 loads with overlap + 1 vec4 store)\n\ndef test(wh=None, w=1024, h=1024, localsz=None, localx=1, localy=1, unrollx=1, unrolly=1, membw=False):\n    global intex, outtex, source\n    if wh is not None:\n        w,h = wh,wh\n    if localsz is not None:\n        localx, localy = localsz\n    src = np.stack([np.stack([np.full(w+2, 1, dtype=np.uint8)]*4, axis=-1)]*h).astype(np.float32)\n    intex = createTexture(w+2, h, fmt=gl.GL_RGBA32F, output=False, src=src)\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {{\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(1,{unrolly});\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s0y = vec4(\n          dot(s0.xyzw, y.xyzw) / 4.,\n          dot(s0.xyzw, y.yxwz) / 4.,\n          dot(s0.xyzw, y.zwxy) / 4.,\n          dot(s0.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 s0z = vec4(\n          dot(s0.xyzw, z.xyzw) / 4.,\n          dot(s0.xyzw, z.yxwz) / 4.,\n          dot(s0.xyzw, z.zwxy) / 4.,\n          dot(s0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 s1x = vec4(\n          dot(s1.xyzw, x.xyzw) / 4.,\n          dot(s1.xyzw, x.yxwz) / 4.,\n          dot(s1.xyzw, x.zwxy) / 4.,\n          dot(s1.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s1z = vec4(\n          dot(s1.xyzw, z.xyzw) / 4.,\n          dot(s1.xyzw, z.yxwz) / 4.,\n          dot(s1.xyzw, z.zwxy) / 4.,\n          dot(s1.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s2x = vec4(\n          dot(s2.xyzw, x.xyzw) / 4.,\n          dot(s2.xyzw, x.yxwz) / 4.,\n          dot(s2.xyzw, x.zwxy) / 4.,\n          dot(s2.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s2y = vec4(\n          dot(s2.xyzw, y.xyzw) / 4.,\n          dot(s2.xyzw, y.yxwz) / 4.,\n          dot(s2.xyzw, y.zwxy) / 4.,\n          dot(s2.xyzw, y.wzyx) / 4.\n      );\n      r0.x += 5.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n          r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2 + \n          s0y+ s0z+ s1x+ s1z+ s2x+ s2y);\n    }}\n    \"\"\"\n    computeShader(source)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//unrolly//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w, h)\n#     assert(output[0,0,0] == reps * 4 * 4)\n    MACs = output.sum()\n#     print(wh, unrollx, elapsed)\n#     print(MACs, elapsed, 4*w*h*4*4)\n\n    if membw:\n        print(output[0,0].sum())\n        return MACs / elapsed / 1e9, 4*w*h*4*4 / elapsed / 1024 / 1024\n    else:\n        return MACs / elapsed / 1e9\n\n# test(localsz=(1,1), unrollx=4, unrolly=4)\ntest()\ntest()\ngflops = test(localx=4, localy=8, membw=True)\nprint(source)\nprint(gflops)\nshowLastShaderDisassembly()\n\n261.0\n\n    #version 310 es\n    precision mediump float;\n\n    layout(local_size_x = 4, local_size_y = 8) in;\n    layout(rgba32f, binding = 0) uniform mediump readonly image2D img_input;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n\n    void main() {\n      ivec2 start_coords = ivec2(gl_GlobalInvocationID.xy) * ivec2(1,1);\n      highp vec4 x, y, z;\n      x = imageLoad(img_input, start_coords + ivec2(0,0));\n      y = imageLoad(img_input, start_coords + ivec2(1,0));\n      z = imageLoad(img_input, start_coords + ivec2(2,0));\n      highp vec4 r0 = vec4(\n          dot(x.xyzw, y.xyzw),\n          dot(x.xyzw, y.yxwz),\n          dot(x.xyzw, y.zwxy),\n          dot(x.xyzw, y.wzyx)\n      );\n      highp vec4 r1 = vec4(\n          dot(x.xyzw, z.xyzw),\n          dot(x.xyzw, z.yxwz),\n          dot(x.xyzw, z.zwxy),\n          dot(x.xyzw, z.wzyx)\n      );\n      highp vec4 r2 = vec4(\n          dot(y.xyzw, z.xyzw),\n          dot(y.xyzw, z.yxwz),\n          dot(y.xyzw, z.zwxy),\n          dot(y.xyzw, z.wzyx)\n      );\n      highp vec4 r3 = vec4(\n          dot(r0.xyzw, z.xyzw) / 4.,\n          dot(r0.xyzw, z.yxwz) / 4.,\n          dot(r0.xyzw, z.zwxy) / 4.,\n          dot(r0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s0 = vec4(\n          dot(x.xyzw, x.xyzw),\n          dot(x.xyzw, x.yxwz),\n          dot(x.xyzw, x.zwxy),\n          dot(x.xyzw, x.wzyx)\n      );\n      highp vec4 s1 = vec4(\n          dot(y.xyzw, y.xyzw),\n          dot(y.xyzw, y.yxwz),\n          dot(y.xyzw, y.zwxy),\n          dot(y.xyzw, y.wzyx)\n      );\n      highp vec4 s2 = vec4(\n          dot(z.xyzw, z.xyzw),\n          dot(z.xyzw, z.yxwz),\n          dot(z.xyzw, z.zwxy),\n          dot(z.xyzw, z.wzyx)\n      );\n      highp vec4 c0 = vec4(\n          dot(s0.xyzw, x.xyzw) / 4.,\n          dot(s0.xyzw, x.yxwz) / 4.,\n          dot(s0.xyzw, x.zwxy) / 4.,\n          dot(s0.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s0y = vec4(\n          dot(s0.xyzw, y.xyzw) / 4.,\n          dot(s0.xyzw, y.yxwz) / 4.,\n          dot(s0.xyzw, y.zwxy) / 4.,\n          dot(s0.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 s0z = vec4(\n          dot(s0.xyzw, z.xyzw) / 4.,\n          dot(s0.xyzw, z.yxwz) / 4.,\n          dot(s0.xyzw, z.zwxy) / 4.,\n          dot(s0.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 c1 = vec4(\n          dot(s1.xyzw, y.xyzw) / 4.,\n          dot(s1.xyzw, y.yxwz) / 4.,\n          dot(s1.xyzw, y.zwxy) / 4.,\n          dot(s1.xyzw, y.wzyx) / 4.\n      );\n      highp vec4 s1x = vec4(\n          dot(s1.xyzw, x.xyzw) / 4.,\n          dot(s1.xyzw, x.yxwz) / 4.,\n          dot(s1.xyzw, x.zwxy) / 4.,\n          dot(s1.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s1z = vec4(\n          dot(s1.xyzw, z.xyzw) / 4.,\n          dot(s1.xyzw, z.yxwz) / 4.,\n          dot(s1.xyzw, z.zwxy) / 4.,\n          dot(s1.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 c2 = vec4(\n          dot(s2.xyzw, z.xyzw) / 4.,\n          dot(s2.xyzw, z.yxwz) / 4.,\n          dot(s2.xyzw, z.zwxy) / 4.,\n          dot(s2.xyzw, z.wzyx) / 4.\n      );\n      highp vec4 s2x = vec4(\n          dot(s2.xyzw, x.xyzw) / 4.,\n          dot(s2.xyzw, x.yxwz) / 4.,\n          dot(s2.xyzw, x.zwxy) / 4.,\n          dot(s2.xyzw, x.wzyx) / 4.\n      );\n      highp vec4 s2y = vec4(\n          dot(s2.xyzw, y.xyzw) / 4.,\n          dot(s2.xyzw, y.yxwz) / 4.,\n          dot(s2.xyzw, y.zwxy) / 4.,\n          dot(s2.xyzw, y.wzyx) / 4.\n      );\n      r0.x += 5.; // optimizer correction\n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n          r0 + r1 + r2 + r3 + s0 + s1 + s2 + c0 + c1 + c2 + \n          s0y+ s0z+ s1x+ s1z+ s2x+ s2y);\n    }\n    \n(24.24173074040384, 5668.957178202975)\nFMAs: 84.47% (261 / 309)\n\nclause_0:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *NOP t0\n    +IADD.s32 t1, r60, 0x00000002 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r3\n}\n\nclause_3:\nds(0) nbb attr ncph next_attr dwb(0) \n{\n    *FMA.f32 t0, r6, r3, #0.neg\n    +FADD.f32 t1, r4, r4\n    *FMA.f32 r0:t0, r5, t1, t0\n    +NOP t1\n    *MKVEC.v2i16 r2:t0, r60, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r7\n}\n\nclause_6:\nds(0) nbb attr ncph dwb(0) \n{\n    *FMA.f32 t0, r10, r7, #0.neg\n    +FADD.f32 t1, r8, r8\n    *FMA.f32 r11:t0, r9, t1, t0\n    +FADD.f32 t1, r9, r9\n    *FMA.f32 t0, r10, t1, #0.neg\n    +FADD.f32 t1, r7, r7\n    *FMA.f32 r12:t0, r8, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r60, 0x00000001 /* 0.000000 */\n    *MKVEC.v2i16 t0, t1, r61\n    +LD_ATTR_TEX.f32.v4 t1, t, #0.x, #0.x, @r13\n}\n\nclause_11:\nds(0) nbb ncph \n{\n    *FMA.f32 r1:t0, r16, r13, #0.neg\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r17:t1, r14, r14\n}\n\nclause_13:\nds(0) nbb ncph \n{\n    *FMA.f32 r1:t0, r15, r17, r1\n    +FADD.f32 t1, r15, r15\n    *FMA.f32 t0, r16, t1, #0.neg\n    +FADD.f32 t1, r13, r13\n    *FMA.f32 r17:t0, r14, t1, t0\n    +NOP t1\n    *FMA.f32 t0, r6, r4, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r5, r3, t0\n    +NOP t1\n    *FMA.f32 r18:t0, r6, r4, t0\n    +NOP t1\n    *FMA.f32 r0:t0, r6, r3, r0\n    +NOP t1\n    *FMA.f32 r18:t0, r5, r3, r18\n    +NOP t1\n}\n\nclause_19:\nds(0) nbb ncph \n{\n    *FMA.f32 r19:t0, r6, r6, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r0, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r20:t0, r18, r14, t0\n    +NOP t1\n    *FMA.f32 r19:t0, r5, r5, r19\n    +FADD.f32 r21:t1, r5, r5\n    *FMA.f32 t0, r6, t1, #0.neg\n    +FADD.f32 r23:t1, r3, r3\n    *FMA.f32 r22:t0, r4, t1, t0\n    +NOP t1\n    *FMA.f32 r19:t0, r4, r4, r19\n    +NOP t1\n    *FMA.f32 r24:t0, r0, r7, #0.neg\n    +NOP t1\n}\n\nclause_25:\nds(0) nbb ncph \n{\n    *FMA.f32 r24:t0, r18, r8, r24\n    +NOP t1\n    *FMA.f32 r20:t0, r22, r15, r20\n    +NOP t1\n    *FMA.f32 r19:t0, r3, r3, r19\n    +NOP t1\n    *FMA.f32 r24:t0, r22, r9, r24\n    +NOP t1\n    *FMA.f32 r20:t0, r19, r16, r20\n    +NOP t1\n    *FMA.f32 t0, r19, r10, r24\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r20:t1, t0, r20\n    *FMA.f32 r24:t0, r10, r8, #0.neg\n    +NOP t1\n}\n\nclause_31:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r9, r7, r24\n    +NOP t1\n    *FMA.f32 r24:t0, r10, r8, t0\n    +NOP t1\n    *FMA.f32 r11:t0, r10, r7, r11\n    +NOP t1\n    *FMA.f32 r24:t0, r9, r7, r24\n    +NOP t1\n    *FMA.f32 t0, r10, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r25:t0, r9, r9, t0\n    +NOP t1\n    *FMA.f32 t0, r11, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r26:t0, r24, r4, t0\n    +NOP t1\n}\n\nclause_37:\nds(0) nbb ncph \n{\n    *FMA.f32 r25:t0, r8, r8, r25\n    +NOP t1\n    *FMA.f32 t0, r11, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r27:t0, r24, r14, t0\n    +NOP t1\n    *FMA.f32 r26:t0, r12, r5, r26\n    +NOP t1\n    *FMA.f32 r25:t0, r7, r7, r25\n    +NOP t1\n    *FMA.f32 r27:t0, r12, r15, r27\n    +NOP t1\n    *FMA.f32 r26:t0, r25, r6, r26\n    +NOP t1\n    *FMA.f32 r27:t0, r25, r16, r27\n    +NOP t1\n}\n\nclause_43:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r26:t1, r27, r26\n    *FMA.f32 t0, r0, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r27:t0, r18, r13, t0\n    +NOP t1\n    *FMA.f32 t0, r0, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r28:t0, r18, r7, t0\n    +NOP t1\n    *FMA.f32 r27:t0, r22, r16, r27\n    +NOP t1\n    *FMA.f32 r28:t0, r22, r10, r28\n    +NOP t1\n    *FMA.f32 r27:t0, r19, r15, r27\n    +NOP t1\n}\n\nclause_49:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r19, r9, r28\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r27:t1, t0, r27\n    *FMA.f32 t0, r16, r14, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r15, r13, t0\n    +NOP t1\n    *FMA.f32 r28:t0, r16, r14, t0\n    +NOP t1\n    *FMA.f32 r1:t0, r16, r13, r1\n    +NOP t1\n    *FMA.f32 r28:t0, r15, r13, r28\n    +NOP t1\n    *FMA.f32 r29:t0, r16, r16, #0.neg\n    +NOP t1\n}\n\nclause_55:\nds(0) nbb ncph \n{\n    *FMA.f32 r29:t0, r15, r15, r29\n    +NOP t1\n    *FMA.f32 t0, r11, r7, #0.neg\n    +NOP t1\n    *FMA.f32 r30:t0, r24, r8, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r7, #0.neg\n    +NOP t1\n    *FMA.f32 r31:t0, r28, r8, t0\n    +NOP t1\n    *FMA.f32 r29:t0, r14, r14, r29\n    +NOP t1\n    *FMA.f32 t0, r11, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r32:t0, r24, r7, t0\n    +NOP t1\n}\n\nclause_61:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r1, r8, #0.neg\n    +NOP t1\n    *FMA.f32 r33:t0, r28, r7, t0\n    +NOP t1\n    *FMA.f32 r30:t0, r12, r9, r30\n    +NOP t1\n    *FMA.f32 r31:t0, r17, r9, r31\n    +NOP t1\n    *FMA.f32 r29:t0, r13, r13, r29\n    +NOP t1\n    *FMA.f32 r32:t0, r12, r10, r32\n    +NOP t1\n    *FMA.f32 r33:t0, r17, r10, r33\n    +NOP t1\n    *FMA.f32 r34:t0, r11, r9, #0.neg\n    +NOP t1\n}\n\nclause_67:\nds(0) nbb ncph \n{\n    *FMA.f32 r34:t0, r24, r10, r34\n    +NOP t1\n    *FMA.f32 t0, r0, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r35:t0, r18, r10, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r9, #0.neg\n    +NOP t1\n    *FMA.f32 r36:t0, r28, r10, t0\n    +NOP t1\n    *FMA.f32 r30:t0, r25, r10, r30\n    +NOP t1\n    *FMA.f32 r31:t0, r29, r10, r31\n    +NOP t1\n    *FMA.f32 r37:t0, r10, r13, #0.neg\n    +NOP t1\n}\n\nclause_73:\nds(0) nbb ncph \n{\n    *FMA.f32 r38:t0, r10, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r39:t0, r11, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r40:t0, r10, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r41:t0, r10, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r42:t0, r0, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r43:t0, r1, r10, #0.neg\n    +NOP t1\n    *FMA.f32 r44:t0, r10, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r45:t0, r10, r4, #0.neg\n    +NOP t1\n}\n\nclause_79:\nds(0) nbb ncph \n{\n    *FMA.f32 r46:t0, r10, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r10:t0, r10, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r37:t0, r9, r14, r37\n    +NOP t1\n    *FMA.f32 r38:t0, r9, r13, r38\n    +NOP t1\n    *FMA.f32 r39:t0, r24, r9, r39\n    +NOP t1\n    *FMA.f32 r40:t0, r9, r16, r40\n    +NOP t1\n    *FMA.f32 r41:t0, r9, r15, r41\n    +NOP t1\n    *FMA.f32 r42:t0, r18, r9, r42\n    +NOP t1\n}\n\nclause_85:\nds(0) nbb ncph \n{\n    *FMA.f32 r43:t0, r28, r9, r43\n    +NOP t1\n    *FMA.f32 r44:t0, r9, r4, r44\n    +NOP t1\n    *FMA.f32 r45:t0, r9, r3, r45\n    +NOP t1\n    *FMA.f32 r46:t0, r9, r6, r46\n    +NOP t1\n    *FMA.f32 r10:t0, r9, r5, r10\n    +NOP t1\n    *FMA.f32 r32:t0, r25, r9, r32\n    +NOP t1\n    *FMA.f32 r9:t0, r29, r9, r33\n    +NOP t1\n    *FMA.f32 r33:t0, r11, r4, #0.neg\n    +NOP t1\n}\n\nclause_91:\nds(0) nbb ncph \n{\n    *FMA.f32 r33:t0, r24, r3, r33\n    +NOP t1\n    *FMA.f32 t0, r11, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r47:t0, r24, r13, t0\n    +NOP t1\n    *FMA.f32 r33:t0, r12, r6, r33\n    +NOP t1\n    *FMA.f32 r47:t0, r12, r16, r47\n    +NOP t1\n    *FMA.f32 r33:t0, r25, r5, r33\n    +NOP t1\n    *FMA.f32 t0, r25, r15, r47\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r33:t1, t0, r33\n}\n\nclause_97:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r1, r13, #0.neg\n    +NOP t1\n    *FMA.f32 r47:t0, r28, r14, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r14, #0.neg\n    +NOP t1\n    *FMA.f32 r48:t0, r28, r13, t0\n    +NOP t1\n    *FMA.f32 r37:t0, r8, r15, r37\n    +NOP t1\n    *FMA.f32 r47:t0, r17, r15, r47\n    +NOP t1\n    *FMA.f32 r38:t0, r8, r16, r38\n    +NOP t1\n    *FMA.f32 r48:t0, r17, r16, r48\n    +NOP t1\n}\n\nclause_103:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r11, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r49:t0, r24, r16, t0\n    +NOP t1\n    *FMA.f32 t0, r0, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r50:t0, r18, r16, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r15, #0.neg\n    +NOP t1\n    *FMA.f32 r51:t0, r28, r16, t0\n    +NOP t1\n    *FMA.f32 r37:t0, r7, r16, r37\n    +NOP t1\n    *FMA.f32 r47:t0, r29, r16, r47\n    +NOP t1\n}\n\nclause_109:\nds(0) nbb ncph \n{\n    *FMA.f32 r52:t0, r11, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r53:t0, r0, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r54:t0, r16, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r55:t0, r16, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r56:t0, r16, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r57:t0, r16, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r16:t0, r1, r16, #0.neg\n    +NOP t1\n    *FMA.f32 r52:t0, r24, r15, r52\n    +NOP t1\n}\n\nclause_115:\nds(0) nbb ncph \n{\n    *FMA.f32 r53:t0, r18, r15, r53\n    +NOP t1\n    *FMA.f32 r54:t0, r15, r4, r54\n    +NOP t1\n    *FMA.f32 r55:t0, r15, r3, r55\n    +NOP t1\n    *FMA.f32 r56:t0, r15, r6, r56\n    +NOP t1\n    *FMA.f32 r57:t0, r15, r5, r57\n    +NOP t1\n    *FMA.f32 r16:t0, r28, r15, r16\n    +NOP t1\n    *FMA.f32 r38:t0, r7, r15, r38\n    +NOP t1\n    *FMA.f32 r15:t0, r29, r15, r48\n    +NOP t1\n}\n\nclause_121:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 t1, r12, r17\n    *FMA.f32 r21:t0, r6, r21, t1\n    +NOP t1\n    *FMA.f32 t0, r11, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r48:t0, r24, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r11, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r58:t0, r24, r5, t0\n    +NOP t1\n    *FMA.f32 r48:t0, r12, r3, r48\n    +NOP t1\n    *FMA.f32 r49:t0, r12, r13, r49\n    +NOP t1\n}\n\nclause_127:\nds(0) nbb ncph \n{\n    *FMA.f32 r39:t0, r12, r8, r39\n    +NOP t1\n    *FMA.f32 r58:t0, r12, r4, r58\n    +NOP t1\n    *FMA.f32 r52:t0, r12, r14, r52\n    +NOP t1\n    *FMA.f32 r12:t0, r12, r7, r34\n    +NOP t1\n    *FMA.f32 r34:t0, r22, r13, r50\n    +NOP t1\n    *FMA.f32 r35:t0, r22, r7, r35\n    +NOP t1\n    *FMA.f32 r34:t0, r19, r14, r34\n    +NOP t1\n    *FMA.f32 r35:t0, r19, r8, r35\n    +NOP t1\n}\n\nclause_133:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r34:t1, r35, r34\n    *FMA.f32 r35:t0, r25, r4, r48\n    +NOP t1\n    *FMA.f32 r48:t0, r25, r14, r49\n    +NOP t1\n    *FMA.f32 r40:t0, r8, r13, r40\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r35:t1, r48, r35\n    *FMA.f32 r48:t0, r17, r13, r51\n    +NOP t1\n    *FMA.f32 r49:t0, r22, r14, r53\n    +NOP t1\n    *FMA.f32 r41:t0, r8, r14, r41\n    +NOP t1\n}\n\nclause_139:\nds(0) nbb ncph \n{\n    *FMA.f32 r50:t0, r14, r5, r54\n    +NOP t1\n    *FMA.f32 r51:t0, r14, r6, r55\n    +NOP t1\n    *FMA.f32 r53:t0, r14, r3, r56\n    +NOP t1\n    *FMA.f32 r54:t0, r14, r4, r57\n    +NOP t1\n    *FMA.f32 r16:t0, r17, r14, r16\n    +NOP t1\n    *FMA.f32 r40:t0, r7, r14, r40\n    +NOP t1\n    *FMA.f32 r14:t0, r29, r14, r48\n    +NOP t1\n    *FMA.f32 r48:t0, r0, r3, #0.neg\n    +NOP t1\n}\n\nclause_145:\nds(0) nbb ncph \n{\n    *FMA.f32 r48:t0, r18, r4, r48\n    +NOP t1\n    *FMA.f32 t0, r0, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r55:t0, r18, r3, t0\n    +NOP t1\n    *FMA.f32 t0, r0, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r56:t0, r18, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r0, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r57:t0, r18, r5, t0\n    +NOP t1\n    *FMA.f32 r42:t0, r22, r8, r42\n    +NOP t1\n}\n\nclause_151:\nds(0) nbb ncph \n{\n    *FMA.f32 r48:t0, r22, r5, r48\n    +NOP t1\n    *FMA.f32 r55:t0, r22, r6, r55\n    +NOP t1\n    *FMA.f32 r56:t0, r22, r3, r56\n    +NOP t1\n    *FMA.f32 r22:t0, r22, r4, r57\n    +NOP t1\n    *FMA.f32 t0, r1, r3, #0.neg\n    +NOP t1\n    *FMA.f32 r57:t0, r28, r4, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r4, #0.neg\n    +NOP t1\n    *FMA.f32 r59:t0, r28, r3, t0\n    +NOP t1\n}\n\nclause_157:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r1, r5, #0.neg\n    +NOP t1\n    *FMA.f32 r60:t0, r28, r6, t0\n    +NOP t1\n    *FMA.f32 t0, r1, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r61:t0, r28, r5, t0\n    +NOP t1\n    *FMA.f32 r43:t0, r17, r8, r43\n    +NOP t1\n    *FMA.f32 r57:t0, r17, r5, r57\n    +NOP t1\n    *FMA.f32 r59:t0, r17, r6, r59\n    +NOP t1\n    *FMA.f32 r36:t0, r17, r7, r36\n    +NOP t1\n}\n\nclause_163:\nds(0) nbb ncph \n{\n    *FMA.f32 r60:t0, r17, r3, r60\n    +NOP t1\n    *FMA.f32 r17:t0, r17, r4, r61\n    +NOP t1\n    *FMA.f32 r49:t0, r19, r13, r49\n    +NOP t1\n    *FMA.f32 r42:t0, r19, r7, r42\n    +NOP t1\n    *FMA.f32 r44:t0, r8, r5, r44\n    +NOP t1\n    *FMA.f32 r45:t0, r8, r6, r45\n    +NOP t1\n    *FMA.f32 r46:t0, r8, r3, r46\n    +NOP t1\n    *FMA.f32 r10:t0, r8, r4, r10\n    +NOP t1\n}\n\nclause_169:\nds(0) nbb ncph \n{\n    *FMA.f32 r41:t0, r7, r13, r41\n    +NOP t1\n    *FMA.f32 r44:t0, r7, r6, r44\n    +NOP t1\n    *FMA.f32 r45:t0, r7, r5, r45\n    +NOP t1\n    *FMA.f32 r46:t0, r7, r4, r46\n    +NOP t1\n    *FMA.f32 r39:t0, r25, r7, r39\n    +NOP t1\n    *FMA.f32 r10:t0, r7, r3, r10\n    +NOP t1\n    *FMA.f32 r7:t0, r29, r7, r43\n    +NOP t1\n    *FMA.f32 r43:t0, r25, r3, r58\n    +NOP t1\n}\n\nclause_175:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r42:t1, r42, r49\n    *FMA.f32 t0, r25, r13, r52\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r43:t1, t0, r43\n    *FMA.f32 r49:t0, r13, r6, r50\n    +NOP t1\n    *FMA.f32 r50:t0, r13, r5, r51\n    +NOP t1\n    *FMA.f32 r51:t0, r13, r4, r53\n    +NOP t1\n    *FMA.f32 r52:t0, r13, r3, r54\n    +NOP t1\n    *FMA.f32 r13:t0, r29, r13, r16\n    +NOP t1\n}\n\nclause_181:\nds(0) nbb ncph \n{\n    *FMA.f32 r0:t0, r30, 0x3e800000 /* 0.250000 */, r0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r1:t1, r11, r1\n    *FMA.f32 t0, r37, r3, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r38, r4, t0\n    +NOP t1\n    *FMA.f32 t0, r40, r5, t0\n    +NOP t1\n    *FMA.f32 r11:t0, r41, r6, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r16:t1, r31, r20\n    *NOP t0\n    +FADD.f32 r20:t1, r47, r26\n}\n\nclause_187:\nds(0) nbb ncph \n{\n    *FMA.f32 t0, r37, r4, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r38, r3, t0\n    +NOP t1\n    *FMA.f32 r26:t0, r40, r6, t0\n    +NOP t1\n    *FMA.f32 r31:t0, r37, r5, #0.neg\n    +FADD.f32 r30:t1, r37, r44\n    *FMA.f32 r37:t0, r37, r6, #0.neg\n    +NOP t1\n    *FMA.f32 r31:t0, r38, r6, r31\n    +NOP t1\n    *FMA.f32 r44:t0, r29, r6, r57\n    +NOP t1\n    *FMA.f32 r6:t0, r19, r6, r48\n    +NOP t1\n}\n\nclause_193:\nds(0) nbb ncph \n{\n    *FMA.f32 r18:t0, r32, 0x3e800000 /* 0.250000 */, r18\n    +NOP t1\n    *FMA.f32 r26:t0, r41, r5, r26\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r24:t1, r24, r28\n    *FMA.f32 r28:t0, r38, r5, r37\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r9:t1, r9, r27\n    *FMA.f32 r27:t0, r29, r5, r59\n    +NOP t1\n    *FMA.f32 r5:t0, r19, r5, r55\n    +NOP t1\n    *FMA.f32 r21:t0, r4, r23, r21\n    +NOP t1\n}\n\nclause_199:\nds(0) nbb ncph \n{\n    *FMA.f32 r23:t0, r29, r8, r36\n    +NOP t1\n    *FMA.f32 r8:t0, r25, r8, r12\n    +NOP t1\n    *FMA.f32 t0, r40, r3, r31\n    +NOP t1\n    *FMA.f32 t0, r41, r4, t0\n    +NOP t1\n    *FMA.f32 r12:t0, t0, 0x3e800000 /* 0.250000 */, r51\n    +NOP t1\n    *FMA.f32 r28:t0, r40, r4, r28\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r15:t1, r15, r33\n    *FMA.f32 r33:t0, r29, r4, r60\n    +NOP t1\n}\n\nclause_205:\nds(0) nbb ncph \n{\n    *FMA.f32 r4:t0, r19, r4, r56\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r23:t1, r23, r34\n    *FMA.f32 r34:t0, r39, 0x3e800000 /* 0.250000 */, r19\n    +NOP t1\n    *FMA.f32 r19:t0, r19, r3, r22\n    +NOP t1\n    *FMA.f32 r22:t0, r41, r3, r28\n    +NOP t1\n    *FMA.f32 r3:t0, r29, r3, r17\n    +NOP t1\n    *FMA.f32 r22:t0, r22, 0x3e800000 /* 0.250000 */, r52\n    +NOP t1\n    *FMA.f32 r8:t0, r8, 0x3e800000 /* 0.250000 */, r21\n    +NOP t1\n}\n\nclause_211:\nds(0) nbb ncph \n{\n    *NOP t0\n    +FADD.f32 r0:t1, r1, r0\n    *FMA.f32 t0, r11, 0x3e800000 /* 0.250000 */, r49\n    +FADD.f32 r1:t1, r30, t\n    *NOP t0\n    +FADD.f32 r11:t1, r44, r16\n    *NOP t0\n    +FADD.f32 r0:t1, r1, r0\n    *FADD.f32 t0, r6, r20\n    +FADD.f32 t1, t, r11\n    *FMA.f32 r0:t0, 0x3e800000 /* 0.250000 */, t1, r0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r32:t1, r38, r45\n    *NOP t0\n    +FADD.f32 r16:t1, r24, r18\n}\n\nclause_217:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 t0, r26, 0x3e800000 /* 0.250000 */, r50\n    +FADD.f32 r18:t1, r32, t\n    *NOP t0\n    +FADD.f32 r9:t1, r27, r9\n    *NOP t0\n    +FADD.f32 r6:t1, r18, r16\n    *FADD.f32 t0, r5, r15\n    +FADD.f32 t1, t, r9\n    *FMA.f32 r1:t0, 0x3e800000 /* 0.250000 */, t1, r6\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r31:t1, r40, r46\n    *NOP t0\n    +FADD.f32 r14:t1, r14, r35\n    *NOP t0\n    +FADD.f32 r15:t1, r33, r23\n}\n\nclause_223:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *FADD.f32 t0, r31, r12\n    +FADD.f32 r8:t1, t, r8\n    *FADD.f32 t0, r4, r14\n    +FADD.f32 t1, t, r15\n    *FMA.f32 r4:t0, 0x3e800000 /* 0.250000 */, t1, r8\n    +NOP t1\n    *NOP t0\n    +FADD.f32 t1, r7, r42\n    *NOP t0\n    +FADD.f32 r3:t1, r3, t1\n    *FADD.f32 t0, r13, r43\n    +FADD.f32 t1, r19, t\n    *NOP t0\n    +FADD.f32 r3:t1, t1, r3\n    *DTSEL_IMM.attribute_1 t0, r2\n    +LEA_ATTR_TEX.f32 t1, t, 0x00000000 /* 0.000000 */, 0x00000001 /* 0.000000 */, @r5\n}\n\nclause_230:\nds(0) eos store \n{\n    *NOP t0\n    +FADD.f32 r17:t1, r25, r29\n    *FADD.f32 t0, r41, 0x40a00000 /* 5.000000 */\n    +FADD.f32 r10:t1, t, r10\n    *NOP t0\n    +FADD.f32 t1, r17, r34\n    *FADD.f32 t0, r10, r22\n    +FADD.f32 t1, t, t1\n    *FMA.f32 t0, 0x3e800000 /* 0.250000 */, r3, t1\n    +MOV.i32 r8:t1, t\n    *MOV.i32 r9:t0, r4\n    +MOV.i32 r10:t1, r1\n    *NOP t0\n    +MOV.i32 r11:t1, r0\n    *NOP t0\n    +ST_CVT.v4 t1, r5, r6, r7, @r8\n}\n\nshader21995 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16], localy=[1,2,4,8,16])\ngrid_show(r, colorfun=lambda x: -x)\n\nde: dump command stream to file pandecode.dump.0348\npandecode: dump command stream to file pandecode.dump.0349\npandecode: dump command stream to file pandecode.dump.0350\npandecode: dump command stream to file pandecode.dump.0351\npandecode: dump command stream to file pandecode.dump.0352\npandecode: dump command stream to file pandecode.dump.0353\npandecode: dump command stream to file pandecode.dump.0354\npandecode: dump command stream to file pandecode.dump.0355\npandecode: dump command stream to file pandecode.dump.0356\npandecode: dump command stream to file pandecode.dump.0357\npandecode: dump command stream to file pandecode.dump.0358\npandecode: dump command stream to file pandecode.dump.0359\npandecode: dump command stream to file pandecode.dump.0360\npandecode: dump command stream to file pandecode.dump.0361\npandecode: dump command stream to file pandecode.dump.0362\npandecode: dump command stream to file pandecode.dump.0363\npandecode: dump command stream to file pandecode.dump.0364\npandecode: dump command stream to file pandecode.dump.0365\npandecode: dump command stream to file pandecode.dump.0366\npandecode: dump command stream to file pandecode.dump.0367\npandecode: dump command stream to file pandecode.dump.0368\npandecode: dump command stream to file pandecode.dump.0369\npandecode: dump command stream to file pandecode.dump.0370\npandecode: dump command stream to file pandecode.dump.0371\npandecode: dump command stream to file pandecode.dump.0372\npandecode: dump command stream to file pandecode.dump.0373\npandecode: dump command stream to file pandecode.dump.0374\npandecode: dump command stream to file pandecode.dump.0375\npandecode: dump command stream to file pandecode.dump.0376\npandecode: dump command stream to file pandecode.dump.0377\npandecode: dump command stream to file pandecode.dump.0378\npandecode: dump command stream to file pandecode.dump.0379\npandecode: dump command stream to file pandecode.dump.0380\npandecode: dump command stream to file pandecode.dump.0381\npandecode: dump command stream to file pandecode.dump.0382\npandecode: dump command stream to file pandecode.dump.0383\npandecode: dump command stream to file pandecode.dump.0384\npandecode: dump command stream to file pandecode.dump.0385\npandecode: dump command stream to file pandecode.dump.0386\npandecode: dump command stream to file pandecode.dump.0387\npandecode: dump command stream to file pandecode.dump.0388\npandecode: dump command stream to file pandecode.dump.0389\npandecode: dump command stream to file pandecode.dump.0390\npandecode: dump command stream to file pandecode.dump.0391\npandecode: dump command stream to file pandecode.dump.0392\npandecode: dump command stream to file pandecode.dump.0393\npandecode: dump command stream to file pandecode.dump.0394\npandecode: dump command stream to file pandecode.dump.0395\npandecode: dump command stream to file pandecode.dump.0396\npandecode: dump command stream to file pandecode.dump.0397\npandecode: dump command stream to file pandecode.dump.0399\npandecode: dump command stream to file pandecode.dump.0400\npandecode: dump command stream to file pandecode.dump.0401\npandecode: dump command stream to file pandecode.dump.0402\npandecode: dump command stream to file pandecode.dump.0403\npandecode: dump command stream to file pandecode.dump.0404\npandecode: dump command stream to file pandecode.dump.0405\npandecode: dump command stream to file pandecode.dump.0406\npandecode: dump command stream to file pandecode.dump.0407\npandecode: dump command stream to file pandecode.dump.0408\npandecode: dump command stream to file pandecode.dump.0409\npandecode: dump command stream to file pandecode.dump.0410\npandecode: dump command stream to file pandecode.dump.0411\npandecode: dump command stream to file pandecode.dump.0412\npandecode: dump command stream to file pandecode.dump.0413\npandecode: dump command stream to file pandecode.dump.0414\npandecode: dump command stream to file pandecode.dump.0415\npandecode: dump command stream to file pandecode.dump.0416\npandecode: dump command stream to file pandecode.dump.0417\npandecode: dump command stream t"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How much does a GPU really pack?",
    "section": "",
    "text": "This repository contains code and benchmark results for compute workloads on constrained (non-desktop) GPUs. We started this project after seeing abysymal performance of TensorFlow Lite on embedded systems and after doing some research we noticed we are not alone with this problem:\nThis seems to be a recurring theme: GPU performance seems to be good on NVidia SoCs and on everything else the ARM CPU is up to 10x faster than the GPU at deep learning inference.\nWe decided to dive deeper and understand where are the performance limits of mobile GPUs and see how we can push them using Open Source drivers and software. All this to deliver faster and more energy efficient deep learning on embedded systems. (we are also working on Open Sourcing NPUs, see Machine Learning with Etnaviv and OpenCL)"
  },
  {
    "objectID": "index.html#neural-network-workloads",
    "href": "index.html#neural-network-workloads",
    "title": "How much does a GPU really pack?",
    "section": "Neural network workloads",
    "text": "Neural network workloads\nBefore we dive into the microbenchmarks we should look into how neural network workloads differ from other compute. Here is a breakdown of a highly effective convolutional neural network (RepVGG A2 which was the precursor to MobileOne the SotA mobile-friendly backbone):\n\n\n\nRepVGG teardown\n\n\nIt is composed of 21 convolutional layers (with a nonlinear activation function applied to each output). The layers which do not change the shape of their input were compressed into a single line but in reality they have to be executed multiple times with different parameters.\nIf you are coming from a DSP background one thing to watch out for is that the inputs (to all but the first layer) are not monochrome or RGB but multi-channel images (In size ^ 2 * In Ch). This means that the convolutional kernels which calculate each output channel using every input channel end up being pretty big (i.e.Â 2.5MB for each of the most compute-intensive 12 layers).\nTo process the whole network the weights and intermediate outputs have to be transfered between the registers and main memory at least once (most likely hundrends of times unless the on-chip memory is very large). The total size of all the intermediate values is around 6MB and the parameters (kernels) â€“ 47MB.\nTo process a single 224x224 RGB image with this network we would need 5GFLOPs."
  },
  {
    "objectID": "index.html#key-takeaways-nfy",
    "href": "index.html#key-takeaways-nfy",
    "title": "How much does a GPU really pack?",
    "section": "Key takeaways (NFY)",
    "text": "Key takeaways (NFY)\nWe started on the ARM Mali-G52 which is a widely implemented low-end GPU. The lessons learned should transfer easily to other mobile GPUs since they are (un)suprisingly very similar to each other. Our current findings about the G52 inside the Amlogic A311D:\nCompute:\n\n76,8 gigainstructions/s (which gives a maximum 38,4 GFLOPS if care only about multiplications)\n\nMemory/cache:\n\n128kB of L2 cache\n16kB L1 cache for the texture unit and another for the load/store unit (64kB of L1 cache for the whole GPU)\nthe L1 caches should have up to 95GB/s of peak memory bandwidth (we currently achieved 19,5GB/s)\n\nRegister file (the fastest memory):\n\nthere are 768 threads multiplexed onto each core (when they use &lt; 64 registers, half of this otherwise)\nthis means the register file has to be 768 âœ• 64 âœ• 32bit = 192kB per core and 384kB for the whole GPU (more then the size of the caches!)\n\nWe are still working to verify some of these numbers (especially the cache memory bandwidths) but this already brings an interesting perspective to what we should keep in which memory region if we want to run neural networks efficiently on such a GPU."
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "How much does a GPU really pack?",
    "section": "Next steps",
    "text": "Next steps\nOver the coming weeks we will release our micro-benchmarks, hunt down the missing L1 memory bandwidth (or figure out why our estimate is unrealistic) and work on an implementation strategy for some fundamental neural network operators (like the fused convolution+activation and attention)."
  },
  {
    "objectID": "a2. estimate gflops (iterative computation, fractals).html",
    "href": "a2. estimate gflops (iterative computation, fractals).html",
    "title": "Estimate GFLOPS (iterative computation, fractals)",
    "section": "",
    "text": "The dot product approach did not succeed in squeezeing the most of the ALU units in the GPU. Here we will try to do iterative computation in a loop. The difficulty is we have to make sure it is not easy for the compiler to optimize it away (so the results have to be unpredictable).\nThe simplest algorithm that satisfies this is probably the Julia fractal which consists of hundreds of complex number multiplications and each pixel gets wildly different (chaotic) results. This gives us a lot of arithmetic with barely any load/store operations (and pretty pictures).\nI am only counting the instructions in the inner loop here (since we run it 4000 times so the rest does not really matter). Itâ€™s surprising how many non-FMA instructions are required to get the job done but we get 74.75 GOPS. Does it add up?\nThe marketing for this SoC seems to talk about G52 MP4 but the hardware register report it having only 2 cores. The most likely explanation is that it has 2 cores with 3 execution units with 8-way SIMD ALU (note that a G52 could also have a 4-way ALU). Since the ALU executes two operations per cycle (but only one of them may be a multiplication) this gives us 96 operations per clock âœ• 800MHz = 76,8 GOPS (for a maximum of 38,4 multiplication GFLOPS).\nThe calculation assumed there are completely no overheads and latencies of any kind so our 74.75 GOPS do look pretty good."
  },
  {
    "objectID": "a2. estimate gflops (iterative computation, fractals).html#test-6-julia-fractal",
    "href": "a2. estimate gflops (iterative computation, fractals).html#test-6-julia-fractal",
    "title": "Estimate GFLOPS (iterative computation, fractals)",
    "section": "Test 6: Julia fractal",
    "text": "Test 6: Julia fractal\n\n\n\n\n\n\nWarning\n\n\n\nThe FMA % numbers printed below are for the whole shader code. Since we have loops, they do not apply and we have to inspect the disassembly, find the loop and manually count the ratio.\n\n\n\nwh = 256\ndef test(wh=wh, localx=1, localy=1, membw=False):\n    global intex, outtex, source\n    w,h = wh,wh\n    if localx * localy &gt; 256: return float('nan')\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision highp float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n    layout(location = 2) uniform int iterations;\n\n    void main() {{\n      vec2 p = (vec2(gl_GlobalInvocationID.xy) / vec2({w}.,{h}.) - vec2(0.5)) * vec2(3.);\n      int r = 0;\n\n      for(int i = 0; i &lt; iterations; i++) {{\n        if(dot(p, p) &lt; 10.) {{\n          r++;\n        }}\n        p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n      }} \n      \n      float n = float(r) / float(iterations) * 4.;\n      \n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n              vec4(0.5-cos(n*75.0)/2.0,0.5-cos(n* 120.0)/2.0,0.5-cos(n*165.0)/2.0,1.0));\n    }}\n    \"\"\"\n    if membw:\n        print(\"\\n\".join([f\"{n+1: 5d}  {line}\" for n, line in enumerate(source.split('\\n'))]))\n    computeShader(source)\n    ITERS = 1000\n    gl.glUniform1i(2, ITERS)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    MACs = 13*ITERS*w*h\n\n    if membw:\n        print(f\"{MACs / elapsed / 1e9:.2f} GFLOPS   {w*h*4*4 / elapsed / 1024 / 1024:.2f} MB/s  {elapsed * 1e3:.2f} ms\")\n    \n    return MACs / elapsed / 1e9\n\ntest()\ngflops = test(localx=16, localy=16, membw=True)\nshowLastShaderDisassembly()\n\n    1  \n    2      #version 310 es\n    3      precision highp float;\n    4  \n    5      layout(local_size_x = 16, local_size_y = 16) in;\n    6      layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n    7      layout(location = 2) uniform int iterations;\n    8  \n    9      void main() {\n   10        vec2 p = (vec2(gl_GlobalInvocationID.xy) / vec2(256.,256.) - vec2(0.5)) * vec2(3.);\n   11        int r = 0;\n   12  \n   13        for(int i = 0; i &lt; iterations; i++) {\n   14          if(dot(p, p) &lt; 10.) {\n   15            r++;\n   16          }\n   17          p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n   18        } \n   19        \n   20        float n = float(r) / float(iterations) * 4.;\n   21        \n   22        imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n   23                vec4(0.5-cos(n*75.0)/2.0,0.5-cos(n* 120.0)/2.0,0.5-cos(n*165.0)/2.0,1.0));\n   24      }\n   25      \n37.42 GFLOPS   43.92 MB/s  22.77 ms\nFMAs: 57.69% (30 / 52)\n\nclause_0:\nds(0) nbb r_uncond ncph \n{\n    *NOP t0\n    +U32_TO_F32 t1, r60\n    *FMA.f32 r0:t0, t1, 0x3b800000 /* 0.003906 */, 0xbf000000 /* -0.500000 */\n    +U32_TO_F32 t1, r61\n    *FMA.f32 r1:t0, t1, 0x3b800000 /* 0.003906 */, 0xbf000000 /* -0.500000 */\n    +NOP t1\n    *FMA.f32 r0:t0, r0, 0x40400000 /* 3.000000 */, #0.neg\n    +NOP t1\n    *FMA.f32 r1:t0, r1, 0x40400000 /* 3.000000 */, #0.neg\n    +MOV.i32 r2:t1, 0x00000000 /* 0.000000 */\n    *NOP t0\n    +MOV.i32 r3:t1, t1\n}\n\nclause_6:\nds(0) nbb r_uncond ncph \n{\n    *NOP t0\n    +ICMP.s32.m1.ge t1, r2, u0.w0\n    *NOP t0\n    +BRANCHZ.i16.eq t1, t1.h0, clause_11\n}\n\nclause_9:\nds(0) nbb \n{\n    *NOP t0\n    +JUMP t1, clause_21\n}\n\nclause_11:\nds(0) nbb ncph \n{\n    *NOP t0\n    +MOV.i32 t1, r1\n    *FMA.f32 r4:t0, r1, t1, #0.neg\n    +MOV.i32 t1, r0\n    *FMA.f32 r5:t0, r0, t1, t0\n    +NOP t1\n}\n\nclause_14:\nds(0) nbb r_uncond \n{\n    *NOP t0\n    +IADD.s32 t1, r3, 0x00000001 /* 0.000000 */\n    *FCMP.f32.lt.m1 t0, r5, 0x41200000 /* 10.000000 */\n    +MUX.i32 r3:t1, r3, t1, t\n    *NOP t0\n    +MOV.i32 t1, r0\n    *FMA.f32 t0, r0, t1, 0x3f49db23 /* 0.788500 */\n    +FADD.f32 r4:t1, t, r4.neg\n    *MOV.i32 t0, r0\n    +FADD.f32 t1, r0, t\n    *FMA.f32 r1:t0, t1, r1, #0.neg\n    +NOP t1\n    *MOV.i32 t0, r2\n    +IADD.s32 r2:t1, t, 0x00000001 /* 0.000000 */\n    *MOV.i32 r0:t0, r4\n    +JUMP t1, clause_6\n}\n\nclause_21:\nds(0) nbb ncph \n{\n    *MOV.i32 t0, r3\n    +S32_TO_F32 r0:t1, t\n    *NOP t0\n    +S32_TO_F32 t1, u0.w0\n    *NOP t0\n    +FRCP.f32 t1, t1\n    *FMA.f32 r0:t0, r0, t1, #0.neg\n    +NOP t1\n}\n\nclause_24:\nds(0) nbb ncph \n{\n    *FMA.f32 r1:t0, 0x43960000 /* 300.000000 */, r0, #0.neg\n    +NOP t1\n    *FMA.f32 r2:t0, t0, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +FADD.f32 t1, t, 0x49400000 /* 786432.000000 */.neg\n    *FMA.f32 r1:t0, t1, 0xbfc90fd0 /* -1.570795 */, r1\n    +FSIN_TABLE.u6 r3:t1, t0\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r2:t1, r2\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r1, r3.neg, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r1:t1, t0, r2\n    *FMA.f32 r2:t0, 0x43f00000 /* 480.000000 */, r0, #0.neg\n    +NOP t1\n}\n\nclause_31:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 r3:t0, r2, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +FADD.f32 t1, t, 0x49400000 /* 786432.000000 */.neg\n    *FMA.f32 r2:t0, t1, 0xbfc90fd0 /* -1.570795 */, r2\n    +FSIN_TABLE.u6 r4:t1, t0\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r3:t1, r3\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r2, r4.neg, t0\n    +NOP t1\n    *FMA.f32 r0:t0, 0x44250000 /* 660.000000 */, r0, #0.neg\n    +FADD.f32 r2:t1, t0, r3\n    *FMA.f32 r3:t0, t0, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r4:t1, t0, 0x49400000 /* 786432.000000 */.neg\n}\n\nclause_38:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *FMA.f32 r0:t0, r4, 0xbfc90fd0 /* -1.570795 */, r0\n    +FSIN_TABLE.u6 r4:t1, r3\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r3:t1, r3\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r0, r4.neg, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 t1, t0, r3\n    *FMA.f32 t0, t1, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 t1, 0x3f000000 /* 0.500000 */, t.neg\n    *MOV.i32 r3:t0, t1\n    +MKVEC.v2i16 t1, r60, r61\n    *DTSEL_IMM.attribute_1 t0, t1\n    +LEA_ATTR_TEX.f32 t1, t, #0.x, #0.x, @r5\n}\n\nclause_45:\nds(0) eos store \n{\n    *FMA.f32 t0, r1, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 r1:t1, 0x3f000000 /* 0.500000 */, t.neg\n    *FMA.f32 t0, r2, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 r2:t1, 0x3f000000 /* 0.500000 */, t.neg\n    *NOP t0\n    +MOV.i32 r4:t1, 0x3f800000 /* 1.000000 */\n    *NOP t0\n    +ST_CVT.v4 t1, r5, r6, r7, @r1\n}\n\nshader11948 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\ndownloadTexture(outtex, 256, 256)\n\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16,32,64,128,256], localy=[1,2,4,8,16,32,64,128,256])\ngrid_show(r, colorfun=lambda x: -np.log(x))\n\ncommand stream to file pandecode.dump.0208\npandecode: dump command stream to file pandecode.dump.0209\npandecode: dump command stream to file pandecode.dump.0210\npandecode: dump command stream to file pandecode.dump.0211\npandecode: dump command stream to file pandecode.dump.0212\npandecode: dump command stream to file pandecode.dump.0213\npandecode: dump command stream to file pandecode.dump.0214\npandecode: dump command stream to file pandecode.dump.0215\npandecode: dump command stream to file pandecode.dump.0216\npandecode: dump command stream to file pandecode.dump.0217\npandecode: dump command stream to file pandecode.dump.0218\npandecode: dump command stream to file pandecode.dump.0219\npandecode: dump command stream to file pandecode.dump.0220\npandecode: dump command stream to file pandecode.dump.0221\npandecode: dump command stream to file pandecode.dump.0222\npandecode: dump command stream to file pandecode.dump.0223\npandecode: dump command stream to file pandecode.dump.0224\npandecode: dump command stream to file pandecode.dump.0225\npandecode: dump command stream to file pandecode.dump.0226\npandecode: dump command stream to file pandecode.dump.0227\npandecode: dump command stream to file pandecode.dump.0228\npandecode: dump command stream to file pandecode.dump.0229\npandecode: dump command stream to file pandecode.dump.0230\npandecode: dump command stream to file pandecode.dump.0231\npandecode: dump command stream to file pandecode.dump.0232\npandecode: dump command stream to file pandecode.dump.0233\npandecode: dump command stream to file pandecode.dump.0234\npandecode: dump command stream to file pandecode.dump.0235\npandecode: dump command stream to file pandecode.dump.0236\npandecode: dump command stream to file pandecode.dump.0237\npandecode: dump command stream to file pandecode.dump.0238\npandecode: dump command stream to file pandecode.dump.0239\npandecode: dump command stream to file pandecode.dump.0240\npandecode: dump command stream to file pandecode.dump.0241\npandecode: dump command stream to file pandecode.dump.0242\npandecode: dump command stream to file pandecode.dump.0243\npandecode: dump command stream to file pandecode.dump.0244\npandecode: dump command stream to file pandecode.dump.0245\npandecode: dump command stream to file pandecode.dump.0246\npandecode: dump command stream to file pandecode.dump.0247\npandecode: dump command stream to file pandecode.dump.0248\npandecode: dump command stream to file pandecode.dump.0249\npandecode: dump command stream to file pandecode.dump.0250\npandecode: dump command stream to file pandecode.dump.0251\npandecode: dump command stream to file pandecode.dump.0252\npandecode: dump command stream to file pandecode.dump.0253\npandecode: dump command stream to file pandecode.dump.0254\npandecode: dump command stream to file pandecode.dump.0255\npandecode: dump command stream to file pandecode.dump.0256\npandecode: dump command stream to file pandecode.dump.0257\npandecode: dump command stream to file pandecode.dump.0258\npandecode: dump command stream to file pandecode.dump.0259\npandecode: dump command stream to file pandecode.dump.0260\npandecode: dump command stream to file pandecode.dump.0261\npandecode: dump command stream to file pandecode.dump.0262\npandecode: dump command stream to file pandecode.dump.0263\npandecode: dump command stream to file pandecode.dump.0264\npandecode: dump command stream to file pandecode.dump.0265\npandecode: dump command stream to file pandecode.dump.0266\npandecode: dump command stream to file pandecode.dump.0267\npandecode: dump command stream to file pandecode.dump.0268\npandecode: dump command stream to file pandecode.dump.0269\npandecode: dump command stream to file pandecode.dump.0270\npandecode: dump command stream to file pandecode.dump.0271\npandecode: dump command stream to file pandecode.dump.0272\npandecode: dump command stream to file pandecode.dump.0273\npandecode: dump command stream to file pandecode.dump.0274\npandecode: dump command stream to file pandecode.dump.0275\npandecode: dump command stream to file pandecode.dump.0276\npandecode: dump command stream to file pa"
  },
  {
    "objectID": "a2. estimate gflops (iterative computation, fractals).html#test-7-julia-fractal-4-way-unroll",
    "href": "a2. estimate gflops (iterative computation, fractals).html#test-7-julia-fractal-4-way-unroll",
    "title": "Estimate GFLOPS (iterative computation, fractals)",
    "section": "Test 7: Julia fractal (4-way unroll)",
    "text": "Test 7: Julia fractal (4-way unroll)\n\nwh = 256\ndef test(wh=wh, localx=1, localy=1, membw=False):\n    global intex, outtex, source\n    w,h = wh,wh\n    if localx * localy &gt; 256: return float('nan')\n    outtex = createTexture(w, h, texid=1, fmt=gl.GL_RGBA32F)\n    source = f\"\"\"\n    #version 310 es\n    precision highp float;\n\n    layout(local_size_x = {localx}, local_size_y = {localy}) in;\n    layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n    layout(location = 2) uniform int iterations;\n\n    void main() {{\n      vec2 p = (vec2(gl_GlobalInvocationID.xy) / vec2({w}.,{h}.) - vec2(0.5)) * vec2(3.);\n      int r = 0;\n\n      for(int i = 0; i &lt; iterations / 4; i++) {{\n        if(dot(p, p) &lt; 10.) {{\n          r++;\n        }}\n        p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n        if(dot(p, p) &lt; 10.) {{\n          r++;\n        }}\n        p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n        if(dot(p, p) &lt; 10.) {{\n          r++;\n        }}\n        p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n        if(dot(p, p) &lt; 10.) {{\n          r++;\n        }}\n        p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n      }} \n      \n      float n = float(r) / float(iterations) * 4.;\n      \n      imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n              vec4(0.5-cos(n*75.0)/2.0,0.5-cos(n* 120.0)/2.0,0.5-cos(n*165.0)/2.0,1.0));\n    }}\n    \"\"\"\n    if membw:\n        print(\"\\n\".join([f\"{n+1: 5d}  {line}\" for n, line in enumerate(source.split('\\n'))]))\n    computeShader(source)\n    ITERS = 1000\n    gl.glUniform1i(2, ITERS)\n    start = time.perf_counter()\n    for i in range(50):\n        gl.glDispatchCompute(w//localx, h//localy, 1)\n        # make sure writing to image has finished before read\n        gl.glMemoryBarrier(gl.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)\n    gl.glFinish()\n    elapsed = (time.perf_counter() - start)/50\n    output = downloadTextureFloat(outtex, w, h)\n    MACs = 32*ITERS/4*w*h\n\n    if membw:\n        print(f\"{MACs / elapsed / 1e9:.2f} GFLOPS   {w*h*4*4 / elapsed / 1024 / 1024:.2f} MB/s  {elapsed * 1e3:.2f} ms\")\n    \n    return MACs / elapsed / 1e9\n\ntest()\ngflops = test(localx=16, localy=16, membw=True)\nshowLastShaderDisassembly()\n\n    1  \n    2      #version 310 es\n    3      precision highp float;\n    4  \n    5      layout(local_size_x = 16, local_size_y = 16) in;\n    6      layout(rgba32f, binding = 1) uniform mediump writeonly image2D img_output;\n    7      layout(location = 2) uniform int iterations;\n    8  \n    9      void main() {\n   10        vec2 p = (vec2(gl_GlobalInvocationID.xy) / vec2(256.,256.) - vec2(0.5)) * vec2(3.);\n   11        int r = 0;\n   12  \n   13        for(int i = 0; i &lt; iterations / 4; i++) {\n   14          if(dot(p, p) &lt; 10.) {\n   15            r++;\n   16          }\n   17          p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n   18          if(dot(p, p) &lt; 10.) {\n   19            r++;\n   20          }\n   21          p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n   22          if(dot(p, p) &lt; 10.) {\n   23            r++;\n   24          }\n   25          p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n   26          if(dot(p, p) &lt; 10.) {\n   27            r++;\n   28          }\n   29          p = vec2(p.x*p.x - p.y*p.y + 0.7885, 2.*p.x*p.y);\n   30        } \n   31        \n   32        float n = float(r) / float(iterations) * 4.;\n   33        \n   34        imageStore(img_output, ivec2(gl_GlobalInvocationID.xy),\n   35                vec4(0.5-cos(n*75.0)/2.0,0.5-cos(n* 120.0)/2.0,0.5-cos(n*165.0)/2.0,1.0));\n   36      }\n   37      \n36.76 GFLOPS   70.12 MB/s  14.26 ms\nFMAs: 59.15% (42 / 71)\n\nclause_0:\nds(0) nbb r_uncond ncph \n{\n    *NOP t0\n    +U32_TO_F32 t1, r60\n    *FMA.f32 r0:t0, t1, 0x3b800000 /* 0.003906 */, 0xbf000000 /* -0.500000 */\n    +U32_TO_F32 t1, r61\n    *FMA.f32 r1:t0, t1, 0x3b800000 /* 0.003906 */, 0xbf000000 /* -0.500000 */\n    +NOP t1\n    *FMA.f32 r0:t0, r0, 0x40400000 /* 3.000000 */, #0.neg\n    +NOP t1\n    *FMA.f32 r1:t0, r1, 0x40400000 /* 3.000000 */, #0.neg\n    +MOV.i32 r2:t1, 0x00000000 /* 0.000000 */\n    *NOP t0\n    +MOV.i32 r3:t1, t1\n}\n\nclause_6:\nds(0) nbb r_uncond ncph \n{\n    *NOP t0\n    +MOV.i32 t1, 0xffffffff /* -nan */\n    *CSEL.s32.gt t0, u0.w0, t1, u0.w0, t1\n    +NOP t1\n    *CSEL.s32.gt r4:t0, 0x00000001 /* 0.000000 */, t0, t0, 0x00000001 /* 0.000000 */\n    +NOP t1\n    *NOP t0\n    +IABS.s32 t1, u0.w0\n    *RSHIFT_OR.i32 t0, t1, #0, 0x00000002 /* 0.000000 */\n    +NOP t1\n    *IMUL.i32 t0, r4, t0\n    +ICMP.s32.m1.ge t1, r2, t\n    *NOP t0\n    +BRANCHZ.i16.eq t1, t1.h0, clause_14\n}\n\nclause_12:\nds(0) nbb \n{\n    *NOP t0\n    +JUMP t1, clause_36\n}\n\nclause_14:\nds(0) nbb ncph \n{\n    *NOP t0\n    +MOV.i32 r4:t1, r1\n}\n\nclause_15:\nds(0) nbb ncph \n{\n    *FMA.f32 r4:t0, r1, r4, #0.neg\n    +MOV.i32 t1, r0\n    *FMA.f32 r5:t0, r0, t1, t0\n    +NOP t1\n    *NOP t0\n    +IADD.s32 t1, r3, 0x00000001 /* 0.000000 */\n    *FCMP.f32.lt.m1 t0, r5, 0x41200000 /* 10.000000 */\n    +MUX.i32 r3:t1, r3, t1, t\n    *NOP t0\n    +MOV.i32 t1, r0\n    *FMA.f32 t0, r0, t1, 0x3f49db23 /* 0.788500 */\n    +FADD.f32 r4:t1, t, r4.neg\n    *MOV.i32 t0, r0\n    +FADD.f32 t1, r0, t\n    *FMA.f32 r0:t0, t1, r1, #0.neg\n    +NOP t1\n}\n\nclause_22:\nds(0) nbb ncph \n{\n    *FMA.f32 r1:t0, r0, r0, #0.neg\n    +NOP t1\n    *FMA.f32 t0, r4, r4, t0\n    +IADD.s32 t1, r3, 0x00000001 /* 0.000000 */\n    *FCMP.f32.lt.m1 t0, t0, 0x41200000 /* 10.000000 */\n    +MUX.i32 r3:t1, r3, t1, t\n    *FMA.f32 r5:t0, r4, r4, 0x3f49db23 /* 0.788500 */\n    +FADD.f32 t1, r4, r4\n    *FMA.f32 r0:t0, t1, r0, #0.neg\n    +NOP t1\n    *FMA.f32 r4:t0, t0, t0, #0.neg\n    +FADD.f32 r1:t1, r5, r1.neg\n    *FMA.f32 t0, t1, t1, t0\n    +IADD.s32 t1, r3, 0x00000001 /* 0.000000 */\n    *FCMP.f32.lt.m1 t0, t0, 0x41200000 /* 10.000000 */\n    +MUX.i32 r3:t1, r3, t1, t\n}\n\nclause_29:\nds(0) nbb r_uncond \n{\n    *FMA.f32 r5:t0, r1, r1, 0x3f49db23 /* 0.788500 */\n    +FADD.f32 t1, r1, r1\n    *FMA.f32 r1:t0, t1, r0, #0.neg\n    +NOP t1\n    *FMA.f32 r0:t0, t0, t0, #0.neg\n    +FADD.f32 r4:t1, r5, r4.neg\n    *FMA.f32 t0, t1, t1, t0\n    +IADD.s32 t1, r3, 0x00000001 /* 0.000000 */\n    *FCMP.f32.lt.m1 t0, t0, 0x41200000 /* 10.000000 */\n    +MUX.i32 r3:t1, r3, t1, t\n    *FMA.f32 t0, r4, r4, 0x3f49db23 /* 0.788500 */\n    +FADD.f32 r0:t1, t, r0.neg\n    *FADD.f32 t0, r4, r4\n    +IADD.s32 r2:t1, r2, 0x00000001 /* 0.000000 */\n    *FMA.f32 r1:t0, t0, r1, #0.neg\n    +JUMP t1, clause_6\n}\n\nclause_36:\nds(0) nbb ncph \n{\n    *MOV.i32 t0, r3\n    +S32_TO_F32 r0:t1, t\n    *NOP t0\n    +S32_TO_F32 t1, u0.w0\n    *NOP t0\n    +FRCP.f32 t1, t1\n    *FMA.f32 r0:t0, r0, t1, #0.neg\n    +NOP t1\n}\n\nclause_39:\nds(0) nbb ncph \n{\n    *FMA.f32 r1:t0, 0x43960000 /* 300.000000 */, r0, #0.neg\n    +NOP t1\n    *FMA.f32 r2:t0, t0, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +FADD.f32 t1, t, 0x49400000 /* 786432.000000 */.neg\n    *FMA.f32 r1:t0, t1, 0xbfc90fd0 /* -1.570795 */, r1\n    +FSIN_TABLE.u6 r3:t1, t0\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r2:t1, r2\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r1, r3.neg, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r1:t1, t0, r2\n    *FMA.f32 r2:t0, 0x43f00000 /* 480.000000 */, r0, #0.neg\n    +NOP t1\n}\n\nclause_46:\nds(0) nbb ncph next_attr \n{\n    *FMA.f32 r3:t0, r2, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +FADD.f32 t1, t, 0x49400000 /* 786432.000000 */.neg\n    *FMA.f32 r2:t0, t1, 0xbfc90fd0 /* -1.570795 */, r2\n    +FSIN_TABLE.u6 r4:t1, t0\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r3:t1, r3\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r2, r4.neg, t0\n    +NOP t1\n    *FMA.f32 r0:t0, 0x44250000 /* 660.000000 */, r0, #0.neg\n    +FADD.f32 r2:t1, t0, r3\n    *FMA.f32 r3:t0, t0, 0x3f22f98c /* 0.636620 */, 0x49400000 /* 786432.000000 */\n    +NOP t1\n    *NOP t0\n    +FADD.f32 r4:t1, t0, 0x49400000 /* 786432.000000 */.neg\n}\n\nclause_53:\nds(0) nbb attr ncph next_store dwb(0) \n{\n    *FMA.f32 r0:t0, r4, 0xbfc90fd0 /* -1.570795 */, r0\n    +FSIN_TABLE.u6 r4:t1, r3\n    *FMA_RSCALE.f32 t0, t0, t0, #0.neg, 0xffffffff /* -nan */\n    +FCOS_TABLE.u6 r3:t1, r3\n    *FMA.f32 t0, t0, t1.neg, #0.neg\n    +NOP t1\n    *FMA.f32.clamp_m1_1 t0, r0, r4.neg, t0\n    +NOP t1\n    *NOP t0\n    +FADD.f32 t1, t0, r3\n    *FMA.f32 t0, t1, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 t1, 0x3f000000 /* 0.500000 */, t.neg\n    *MOV.i32 r3:t0, t1\n    +MKVEC.v2i16 t1, r60, r61\n    *DTSEL_IMM.attribute_1 t0, t1\n    +LEA_ATTR_TEX.f32 t1, t, #0.x, #0.x, @r5\n}\n\nclause_60:\nds(0) eos store \n{\n    *FMA.f32 t0, r1, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 r1:t1, 0x3f000000 /* 0.500000 */, t.neg\n    *FMA.f32 t0, r2, 0x3f000000 /* 0.500000 */, #0.neg\n    +FADD.f32 r2:t1, 0x3f000000 /* 0.500000 */, t.neg\n    *NOP t0\n    +MOV.i32 r4:t1, 0x3f800000 /* 1.000000 */\n    *NOP t0\n    +ST_CVT.v4 t1, r5, r6, r7, @r1\n}\n\nshader14548 - MESA_SHADER_COMPUTE shader: 0 inst, 0 bundles, 0 quadwords, 0 registers, 4 threads, 0 loops, 0:0 spills:fills\n\n\n\n\nr = grid_run(test, localx=[1,2,4,8,16,32,64,128,256], localy=[1,2,4,8,16,32,64,128,256])\ngrid_show(r, colorfun=lambda x: -np.log(x))"
  }
]